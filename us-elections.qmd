---
filters:
  - line-highlight
execute: 
  freeze: auto
fig-width: 5
fig-asp: 0.5
---

```{r}
#| echo: false
#| eval: true
#| file: R/options.R
```

```{r}
#| echo: false
#| eval: true
#| file: R/load_font_awesome.R
```

```{r}
#| echo: false
#| eval: true
#| file: R/social_caption.R
```

# US House elections: geography on a grid with {geofacet} {#sec-house}

In this chapter, we'll learn how to arrange faceted plots in a grid that resembles a geographic area with {geofacet}, and look at another approach for creating customized legends. \index{geofacet} \index{patchwork}

## Data

\index{tidytuesdayR!tt\_load}

[@elections_data]

```{r}
#| label: elections-load-data-show
#| eval: false
#| echo: true
tuesdata <- tidytuesdayR::tt_load("2023-11-07")
house <- tuesdata$house
```

```{r}
#| label: elections-load-data-hide
#| output: false
#| echo: false
#| eval: true
house <- readr::read_csv("data/house.csv")
```

\index{utils!head}

Let's take a look at the first few rows of the data:

```{r}
#| label: elections-head-data
head(house)
```

There are many `state` columns, essentially providing similar information in different formats e.g. the `state` column provides the state name and the `state_po` column provides the state two letter abbreviation.

## Exploratory work

### Data exploration

We might be interested in whether or not the number of votes has changed over time. The data goes back to 1976 and the population of the USA has increased by over 150% between the 1970 and 2020 censuses [@UScensuspop] so might we also expect a similar increase in votes? Let's start by having a look at the number of candidate votes over time with a quick scatter plot made with `plot()`:

```{r}
#| label: fig-elections-scatterplot
#| fig-cap: "Bar chart "
#| echo: -1
#| fig-asp: 0.8
par(mar = c(4.1, 4.1, 2.1, 2.1))
plot(
  x = house$year,
  y = house$candidatevotes,
  xlab = "",
  ylab = "Candidate votes"
)
```

There doesn't seem to be an especially interesting pattern in votes over time, at least at first glance, in @fig-elections-scatterplot. However, it has highlighted a potential data issue. In most years, the highest values are around 300,000 but there are two observations in 2022 where the values are well over 1,000,000. We had a similar issue in @sec-bees, where some observations were the sum of other observations. This doesn't seem to be the case here. For now, let's exclude these and look at data where the number of candidate votes is below 600,000.

We might also be interested in how the number of candidate votes varies by party, and we can create a box plot ...

```{r}
#| label: fig-elections-boxplot
#| fig-cap: "Box plot "
#| fig-asp: 1.2
#| echo: -1
par(mar = c(4.1, 6.1, 1.1, 1.1))
boxplot(
  candidatevotes ~ party,
  data = house[house$candidatevotes < 600000, ],
  horizontal = TRUE,
  cex.axis = 0.5,
  cex.names = 0.5,
  las = 1,
  xlab = "Number of candidate votes",
  ylab = NULL
)
```

In @fig-elections-boxplot there are a couple of interesting points to note. First, there are many, many unique `party` names because every independent candidate is listed as a different party name. This means that not all party names can actually by read off from the chart. Secondly, there is a lot

### Exploratory sketches

![Initial sketch of a faceted area chart arranged in a grid shaped like the United States. An enlarged version of one area chart is used as a legend on the left hand side.](images/sketch-elections.png){#fig-elections-sketch fig-align="center"}

## Preparing a plot

### Data wrangling

\index{dplyr!mutate}

\index{dplyr!case\_when} \index{dplyr!filter} \index{dplyr!group\_by} \index{dplyr!summarise} \index{dplyr!ungroup}

```{r}
#| label: elections-wrangling
house_data <- house |>
  dplyr::mutate(party = dplyr::case_when(
    party == "REPUBLICAN" ~ "Republican",
    party == "DEMOCRAT" ~ "Democrat",
    TRUE ~ "Other"
  )) |>
  dplyr::filter(stage == "GEN") |>
  dplyr::group_by(year, state_po, party) |>
  dplyr::summarise(votes = sum(candidatevotes)) |>
  dplyr::ungroup()
```

There are some years for which there were no `"Other"` candidates in some states, and so there are no rows for these values i.e. they are implicitly missing. As we saw in @sec-r-pkgs, this can cause misleading area charts and results in a warning from {ggplot2}. As in @sec-r-pkgs, these *missing* values are not actually missing, they are simply 0. We'll do as we did before and make sure that every combination of `year`, `state_po`, and `party` exists in the data by using `complete()` from {tidyr}, and setting any *missing* combinations explicitly to 0. \index{tidyr!complete}

```{r}
#| label: elections-wrangling2
plot_data <- house_data |>
  tidyr::complete(
    year, state_po, party,
    fill = list(votes = 0)
  )
```

### The first plot

We're once again going to create a faceted plot, as we did in @sec-programming, @sec-museums, and @sec-technology. There are two key differences with this plot:

* Instead of arranging the plots into a rectangular shape with a specified number of rows and columns, we want to arrange the plots in a way that resembles some underlying geography.
* There are far more facets (over 50) compared to the previous plots we've made (which have mostly had less than 10). Sometimes creating a large number of facets can be slow.

It's this second issue that means when developing faceted plots, especially when using large data or a complex visualization, it can be useful to create a single plot first. That is, filter the data and create a chart for just one level of the faceting category. This allows you to get the basics of your chart correct, before you start worrying about facet layout.

We start by passing in our `plot_data` to to the `data` argument of `ggplot()`, wrapped inside the `filter()` function from {dplyr} which subsets the data to just California. We set up the aesthetic mapping to plot the year on the x-axis and the number of votes on the y-axis, split by party. \index{dplyr!filter} \index{ggplot2!ggplot} \index{ggplot2!aes}

We've already seen examples of making area charts in @sec-museums and @sec-r-pkgs, but we're going to make a slight change in this chapter. Since we're going to be comparing states (which each have very different population sizes, and therefore will have very different numbers of votes), rather than considering an area chart of number of votes, we'll look at the proportion for each party. Luckily, we don't have to calculate these percentages ourselves, since setting `position = "fill"` inside `geom_area()` does this for us. \index{ggplot2!geom\_area}

```{r}
#| label: fig-elections-single-plot
#| fig-cap: "Plot"
#| warning: false
library(ggplot2)
ggplot(
  data = dplyr::filter(plot_data, state_po == "CA")
) +
  geom_area(
    mapping = aes(
      x = year,
      y = votes,
      fill = party
    ),
    position = "fill"
  )
```

We now have a basic plot for one of the facet values.

::: {#tip-elections-piping .callout-tip}

## Piping data into `ggplot()`

Since the first argument of `ggplot` is `data`, this means that we *could* pipe the data into the `ggplot()` function rather than explicitly stating it as the first argument. For example, the code above could be re-written as:

```{r}
#| label: elections-plot-piping
#| eval: false
#| echo: true
plot_data |>
  dplyr::filter(, state_po == "CA") |>
  ggplot() +
  geom_area(
    mapping = aes(
      x = year,
      y = votes,
      fill = party
    ),
    position = "fill"
  )
```

Though this may arguably look neater than nesting `filter()` inside `ggplot()`, you're unlikely to see any other examples of piping into `ggplot()` for two reasons:

* The combination of `+` and `|>` looks odd, and this outweighs the increased neatness from piping (personal opinion).
* It makes it easier to end up with very long, complicated code. Keeping the data wrangling and the plotting code separate often makes more sense.

:::

We can now pass the full data into `ggplot()` (rather than just the California subset) and add `facet_wrap()` to create an area chart for each value in `state_po`. \index{ggplot2!ggplot} \index{ggplot2!aes} index{ggplot2!geom\_area} \index{ggplot2!facet\_wrap}

```{r}
#| label: fig-elections-basic-plot
#| fig-cap: "Plot"
#| warning: false
#| source-line-numbers: "1,10"
basic_plot <- ggplot(data = plot_data) +
  geom_area(
    mapping = aes(
      x = year,
      y = votes,
      fill = party
    ),
    position = "fill"
  ) +
  facet_wrap(~state_po)
basic_plot
```

In @fig-elections-basic-plot, we can't actually see any of our area charts, only the facet labels. This is a very common problem when working with large numbers of facet categories, and smaller chart sizes. We'll deal with this problem a little bit later when adjusting the plot themes. 

### Faceting with {geofacet}

To arrange the faceted plots into a grid that resembles the underlying geography, we'll use the {geofacet} package [@geofacet]. The {geofacet} package makes it easier to arrange facets in the shape of a map. This makes it easier to compare data across regions, like states or countries, in a grid format. There are many built-in grids for different geographical regions, including the several for the United States of America. However, you can also create your own custom facet grid if you prefer a different layout, or if no grid exists for the region you are plotting.

To do faceting with {geofacet}, we use `facet_geo()` instead of `facet_wrap()`. It works in essentially the same way, and we start by using a `~` to indicate which column is the faceting column. However, there are two things that are a little bit different: \index{geofacet!facet\_geo} \index{geofacet!facet\_geo}

* We need to specify which grid layout we want to use. You can use the `get_grid_names()` function in {geofacet} to get a list of all of the valid grid names. They are named sensibly based on what region the grid is for e.g. `"us_state_grid1"` and `"eu_grid1"`. Here, we'll use `"us_state_grid2"`. 

* In order to map the data to the correct facet position on the grid, one of the columns in the data must align with the value in the `code` column of your chosen grid. In the `"us_state_grid2"` grid, the `code` column contains the two letter state abbreviations which matches the `state_po` column in our data. If you didn't have the two letter abbreviations, you may need to do so data joining to attach them.

If you have additional *states* (e.g. Puerto Rico can sometimes be listed in a US state column even though it isn't) or are missing some states, you can still use `geo_facet()`. However, it will only plot states listed in the facet grid, and you may get a warning message.

```{r}
#| label: fig-elections-geofacet-plot
#| fig-cap: "Plot"
#| warning: false
library(geofacet)
map_plot <- basic_plot +
  geofacet::facet_geo(
    ~state_po,
    grid = "us_state_grid2"
  )
map_plot
```

We still have the same problem of not being able to see the details of the chart as there are so many, but you can see from just the facet titles, that the plots are now arranged in a grid that resembles the USA. 

## Advanced styling

We'll now style our charts to apply more intuitive colors, adjust the facet labels to allow the charts to be seen more easily, and create a custom legend that explains how to read this chart.

### Colors

In the USA, the Republican party is represented by the color red and the Democrat party by blue. As we discussed in @sec-lemurs, when choosing which colors to use for well-known categories, it's important not to play into negative stereotypes (e.g. pink for girls). But it's also important to use what is intuitive. Since these are colors that the parties have chosen to represent themselves, and because they are so well recognized, we'll stick to red and blue. 

other colors

```{r}
#| label: elections-colors
blue_col <- "#0015BC"
red_col <- "#C41E3A"
other_col <- "#AAAAAA"
text_col <- "#202A44"
bg_col <- "#FAFAFA"
```

\index{ggplot2!scale\_fill\_manual}

```{r}
#| label: elections-add-colors
#| warning: false
col_plot <- map_plot +
  scale_fill_manual(
    values = c(
      "Democrat" = blue_col,
      "Republican" = red_col,
      "Other" = other_col
    )
  )
```

\index{ggplot2!scale\_fill\_manual}

### Text and fonts

{sysfonts}\index{sysfonts}
{showtext}\index{showtext}

\index{sysfonts!font\_add\_google}
\index{showtext!showtext\_auto}
\index{showtext!showtext\_opts}

```{r}
#| label: elections-fonts
sysfonts::font_add_google(
  name = "Roboto", family = "roboto"
)
sysfonts::font_add_google(
  name = "Carter One", family = "carter"
)
showtext::showtext_auto()
showtext::showtext_opts(dpi = 300)
body_font <- "roboto"
title_font <- "carter"
```


\index{glue!glue}
\index{base!paste0}

As in @sec-time-zones, we'll add the information about the source of the data on a new line at the end of subtitle, rather than in the caption. 

```{r}
#| label: elections-text
title <- "US House Election Results"
st <- glue::glue("Areas indicate the percentage of votes for <span style='color:{blue_col};'>Democrat</span>, <span style='color:{red_col};'>Republican</span>, and <span style='color:#aaaaaa;'>Other</span> parties in general elections between 1976 and 2022.<br><br>**Data**: U.S. House 1976â€“2022. MIT Election Data and Science Lab.")
```

We also define our `social_caption()` using the function we defined in @sec-cats: \index{social\_caption}

```{r}
#| label: elections-text-2
social <- social_caption(
  icon_color = blue_col,
  font_color = text_col,
  font_family = body_font
)
```

We then pass our title, subtitle, and caption text intp the `labs()` function to add it to our plot. Since we want to position the subtitle text in an unusual place, we use the `tag` argument rather than `subtitle`, similar to what we did in @sec-time-zones. \index{ggplot2!labs} 

```{r}
#| label: elections-labs
text_plot <- col_plot +
  labs(
    title = title,
    tag = cap,
    caption = social
  )
```


### Adjusting themes

\index{ggplot2!geom\_text} \index{ggplot2!coord\_cartesian}
\index{ggplot2!aes} \index{ggplot2!alpha}

```{r}
#| label: fig-elections-geofacet-style-1
#| fig-cap: "Plot"
#| warning: false
styled_plot_1 <- text_plot +
  geom_text(
    mapping = aes(
      x = mean(range(year)),
      y = 0.5,
      label = state_po
    ),
    family = title_font,
    color = alpha(bg_col, 0.5),
    size = 2.5
  ) +
  coord_cartesian(expand = FALSE)
```

\index{ggplot2!theme\_void}

\index{ggplot2!theme} \index{ggplot2!element\_rect} \index{ggplot2!margin}
\index{ggplot2!element\_blank} \index{ggtext!element\_textbox\_simple}
\index{ggplot2!unit} \index{ggplot2!rel}

```{r}
#| label: fig-elections-plot-style-2
#| fig-cap: "Plot"
#| warning: false
styled_plot_2 <- styled_plot_1 +
  theme_void(base_size = 6, base_family = body_font) +
  theme(
    plot.background = element_rect(
      fill = bg_col,
      color = bg_col
    ),
    panel.background = element_rect(
      fill = bg_col,
      color = bg_col
    ),
    plot.margin = margin(5, 5, 5, 125),
    legend.position = "none",
    plot.title = ggtext::element_textbox_simple(
      hjust = -0.94,
      halign = -0.94,
      color = text_col,
      face = "bold",
      family = title_font,
      size = rel(1.4)
    ),
    plot.tag = ggtext::element_textbox_simple(
      hjust = 0,
      color = text_col,
      maxwidth = 0.65,
      lineheight = 0.6,
      size = rel(1.0)
    ),
    plot.caption = ggtext::element_textbox_simple(
      hjust = 1,
      halign = 1,
      color = text_col,
      maxwidth = 0.65,
      margin = margin(b = 0, t = 10)
    ),
    strip.background = element_blank(),
    strip.text = element_blank(),
    panel.spacing = unit(0.05, "lines"),
    plot.tag.position = c(-0.51, 0.74)
  )
styled_plot_2
```


### Legend

As we did in @sec-time-zones, we'll design a custom legend. In @sec-time-zones, we used a bar chart as a legend which also served as another source of information in the visualization. In this chapter, our custom legend will instead serve as a *how to read this chart* explainer.

We can take one of the facets, enlarge it, and add annotations to explain what data is shown on the chart. To keep the main chart looking clean, we don't currently have any axes titles or labels. For example, it's not immediately clear what years are covered by the data. This doesn't need added to every chart, but should be annotated on the legend. To increase the accessibility of the chart, and to make sure we don't rely on color alone as discussed in @sec-lemurs, we'll also add direct labels to identify the *Democrat* and *Republican* areas on the chart.

Let's start by filtering the data, to select only a single state. It doesn't really matter which one we choose, although ideally one that has enough space for us to add the party labels directly on the chart. Here, we'll use California (`"CA"`) for the legend plot. \index{dplyr!filter}

```{r}
#| label: elections-legend-data
ca_data <- dplyr::filter(plot_data, state_po == "CA")
```

direct labeling as discusses 
\index{ggplot2!ggplot} \index{ggplot2!aes}
\index{ggplot2!geom\_area}
\index{ggplot2!geom\_text}
\index{ggplot2!scale\_fill\_manual}


```{r}
#| label: elections-ca-plot
ca_plot <- ggplot(data = ca_data) +
  geom_area(
    mapping = aes(
      x = year,
      y = votes,
      fill = party
    ),
    position = "fill"
  ) +
  # label for state
  geom_text(
    mapping = aes(
      x = mean(range(year)),
      y = 0.5,
      label = state_po
    ),
    family = title_font,
    color = alpha(bg_col, 0.7),
    size = 4
  ) +
  # colors
  scale_fill_manual(
    values = c(
      "Democrat" = blue_col,
      "Republican" = red_col,
      "Other" = other_col
    ),
    guide = "none"
  )
```

We then use the `annotate()` function to add: \index{ggplot2!annotate}

* Two labels for the start and end year of the data. To keep these within the bounds of the plot, we left align the start label on the left, and right align the end label on the right. 

* Two labels for the *Republican* and *Democrat* parties. We leave the *Other* category unlabeled as it's very small, and it's obviously the only category left over. 

As in the main plot, we also set `expand = FALSE` inside `coord_cartesian()` to remove the additional space around the edges. We also use `theme_void()` to remove any additional chart elements, since the annotations convey all the necessary information. \index{ggplot2!coord\_cartesian} \index{ggplot2!theme\_void}

```{r}
#| label: fig-elections-inset-plot
#| fig-cap: "A custom legend plot consisting of a zoomed in version of the California facet with additional annotations indicating the time period and categories represented by different colors."
#| fig-asp: 1
#| fig-width: 3
#| fig-align: center
p_inset <- ca_plot +
  # year labels
  annotate(
    geom = "text",
    x = min(ca_data$year),
    y = 0.1,
    label = min(ca_data$year),
    family = body_font,
    color = bg_col,
    size = 3,
    hjust = 0
  ) +
  annotate(
    geom = "text",
    x = max(ca_data$year),
    y = 0.1,
    label = max(ca_data$year),
    family = body_font,
    color = bg_col,
    size = 3,
    hjust = 1
  ) +
  # Party labels
  annotate(
    geom = "text",
    x = mean(range(ca_data$year)),
    y = 0.8,
    label = "Democrat",
    family = body_font,
    color = bg_col,
    size = 3.5
  ) +
  annotate(
    geom = "text",
    x = mean(range(ca_data$year)),
    y = 0.2,
    label = "Republican",
    family = body_font,
    color = bg_col,
    size = 3.5
  ) +
  coord_cartesian(expand = FALSE) +
  theme_void()
p_inset
```

### Joining with {patchwork}

Now, the last step is to join together our custom legend with the main plot. We've already left some blank space on the main plot for the legend to go in, so we'll use the `inset_element()` function from {patchwork} [@patchwork] as we did in @sec-time-zones. \index{patchwork} \index{patchwork!inset\_element}





\index{ggplot2!theme} \index{ggplot2!element\_rect}

```{r}
#| label: fig-combine-plots
#| fig-cap: "Plot"
library(patchwork)
styled_plot_2 + inset_element(
  p = p_inset,
  left = 0.027,
  bottom = 0.087,
  right = 0.287,
  top = 0.55,
  align_to = "full",
  clip = FALSE
) +
  theme(
    plot.background = element_rect(
      fill = bg_col,
      color = bg_col
    ),
    panel.background = element_rect(
      fill = bg_col,
      color = bg_col
    )
  )
```


## Reflection

* Other category

* prcent

::: {.content-visible when-format="html"}

Each plot created during the process of developing the original version of this visualization was captured using {camcorder}, and is shown in the gif below. If you'd like to learn more about how {camcorder} can be used in the data visualization process, see @sec-camcorder.

![](images/elections.gif){fig-align="center"}

:::

## Exercises

::: {.callout-caution}

Exercises are coming soon!

:::
