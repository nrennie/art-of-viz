---
fig-width: 5
fig-asp: 0.67
fig-align: center
fig-dpi: 300
filters:
  - line-highlight
execute: 
  freeze: auto
---

# Doctors in an ageing population: making maps with {ggplot2} {#doctors}

In this chapter we'll learn how to identify open data sources, make maps with {ggplot2} using data from the {maps} package, and create title panels with an unorthodox use of facets.

## Data 

* Bring your own data

\#TidyTuesday\index{TidyTuesday} [@tidytuesday]


* Common data sources

* Doctors data



The ... comes from Our World in Data [@doctors_data]

```{r}
#| label: load-doctors-data
#| output: false
doctors <- readr::read_csv("data/doctors.csv")
```

\index{readr!read\_csv}

## Exploratory work

### Data exploration

what does data look like

### Exploratory sketches

aspect ratio

## Preparing a plot

### Data wrangling

Since this data is already fairly tidy, there isn't too much data wrangling to be done. The only processing we really need to do is getting rid of the data we don't need, and renaming a couple of columns to make them easier to work with. We can use the `rename()` function from {dplyr} to rename the `entity` column to `region` (for reasons that will become clear in the next paragraph!). We also rename the `Physicians (per 1,000 people)` column to `doctors` to make it easier to work with. The data has multiple entries for each country, spanning different years. We *could* make an animated map to show how the number of doctors is changing over time, but for now we'll keep it simple with a static map showing a snapshot at one point in time. However, there's a bit of a problem. If you inspect the data, you'll see that not every country has an entry for each year - let's use the most recent data available for each country. For each `region`, we keep the row with only the most recent year using a combination of `group_by()`\index{dplyr!group\_by} and `slice_max()`\index{dplyr!slice\_max} from {dplyr}.

```{r}
#| label: doctors-wrangle
#| message: false
doctors <- doctors |>
  dplyr::rename(
    region = entity,
    doctors = `Physicians (per 1,000 people)`) |>
  dplyr::select(region, year, doctors) |>
  dplyr::group_by(region) |>
  dplyr::slice_max(year) |>
  dplyr::ungroup()
```

To plot this data on a world map, we also need data for the country borders. Luckily, the `map_data()` function built into {ggplot2}\index{ggplot2!map\_data} can help us with that! This function takes data from the {maps} package\index{maps} and turns it into an object you can plot directly with {ggplot2}.

```{r}
#| label: map-doctors
#| message: false
library(ggplot2)
world <- map_data("world")
```

Of course, it's never quite that straightforward. We need to join the `world` map data to our `doctors` data, and to do that we need a column in each data sets to join by - we'll use the `region` column. If you try to join these two data sets using the `region` column, you'll notice that you end up with some unexpected `NA` values. So what's going on?

> You don't need to rename columns in your data to be able to join them, but for this example, I found it a little bit easier to work with the data after renaming `entity` to `region`.

There are two issues here. Firstly, there are more regions in the `world` data than there are in the `doctors` data:

```{r}
#| label: map-doctors-length
length(unique(world$region))
length(unique(doctors$region))
```

If you go ahead and inspect the country names, you'll see that for some countries, they are encoded differently. For example, in the `world` data, the United States is listed as `"USA"` whilst in the `doctors` data, it's listed as `"United States"`. Here, the easiest thing to do is manually rename the values that differ in one of the datasets. We can use the `recode()` function from {dplyr} to do that.\index{dplyr!recode} Note that `recode()` has the rather unusual (for the {tidyverse}) syntax of `old_name = new_name`:

```{r}
#| label: map-doctors-wrangle-1
plot_data <- doctors |>
  dplyr::mutate(
    region =
      dplyr::recode(region,
        "United Kingdom" = "UK",
        "United States" = "USA",
        "Congo, Dem. Rep." = "Democratic Republic of the Congo",
        "Cote d'Ivoire" = "Ivory Coast",
        "Congo, Rep." = "Republic of Congo")
  )
```

\index{dplyr!left\_join} and filter out Antarctica \index{dplyr!filter}


```{r}
#| label: map-doctors-wrangle-2
map_data <- dplyr::left_join(world, plot_data, by = "region") |>
  dplyr::filter(region != "Antarctica")
```


### The first plot

\index{ggplot2!geom\_map}

\index{map}

```{r}
#| label: fig-doctors-basic-plot-1
#| fig-cap: "Map of the world with countries colored based on number of doctors per 1,000 people. The map looks stretched."
base_plot <- ggplot(
  data = map_data,
  mapping = aes(
    long,
    lat,
    map_id = region,
    fill = doctors)) +
  geom_map(map = map_data)
base_plot
```

## Advanced styling

### Colors

\index{MetBrewer}

```{r}
#| label: doctors-colors
library(MetBrewer)
col_palette <- met.brewer("Hokusai2", n = 20)
text_col <- col_palette[18]
highlight_col <- col_palette[15]
bg_col <- "#EADEDA"
```

\index{ggplot2!scale\_fill\_gradientn}

```{r}
#| label: fig-doctors-style-plot-1
#| fig-cap: "Map of the world with countries colored based on number of doctors per 1,000 people, showing a different color scheme."
col_plot <- base_plot +
  scale_fill_gradientn(
    colors = col_palette,
    limits = c(0, 10),
    breaks = c(0.5, 9.5),
    labels = c("Fewer doctors", "More doctors")) +
  guides(fill = guide_colorbar(ticks = FALSE))
col_plot
```

### Text and fonts

{sysfonts}\index{sysfonts}
{showtext}\index{showtext}

\index{sysfonts!font\_add\_google}
\index{showtext!showtext\_auto}
\index{showtext!showtext\_opts}

```{r}
#| label: doctors-font
sysfonts::font_add_google(name = "Roboto", family = "roboto")
showtext::showtext_auto()
showtext::showtext_opts(dpi = 300)
body_font <- "roboto"
```


```{r}
#| label: doctors-text
title <- "Doctors in an ageing population"
st <- "This map show the number of doctors per thousand people, rescaled by the percentage of the population aged over 70, revealing which countries* may be more likely to struggle in providing care for an elderly population.<br><br>*using the most recent available data for each country."
cap <- "**Data**: Our World in Data | **Graphic**: N. Rennie"
```

```{r}
#| label: doctors-style-plot-2
text_plot <- col_plot +
  labs(title = title, subtitle = st, caption = cap)
```

### Adjusting themes

\index{ggtext!element\_textbox\_simple}

```{r}
#| label: fig-doctors-style-plot-3
#| fig-cap: "Map of the world with countries colored based on number of doctors per 1,000 people. Styling ..."
library(ggtext)
text_plot +
  theme_void(base_size = 8, base_family = body_font) +
  theme(
    plot.margin = margin(10, 10, 10, 10),
    plot.background = element_rect(
      fill = bg_col, color = bg_col),
    panel.background = element_rect(
      fill = bg_col, color = bg_col),
    plot.title = element_textbox_simple(
      color = text_col),
    plot.subtitle = element_textbox_simple(
      color = text_col),
    plot.caption = element_textbox_simple(
      hjust = 0,
      color = text_col)
  )
```


Box for title facets

\index{ggplot2!facet\_wrap}

```{r}
#| label: doctors-facets
map_data$label <- title
```

While we're here, let's lines of map same color as bg and a little bit thinner

```{r}
#| label: fig-doctors-style-plot-4
#| fig-cap: "caption"
styled_plot <- ggplot(
  data = map_data,
  mapping = aes(
    long,
    lat,
    map_id = region,
    fill = doctors)) +
  geom_map(
    map = map_data,
    color = bg_col,
    linewidth = 0.3) +
  scale_fill_gradientn(
    colors = col_palette,
    limits = c(0, 10),
    breaks = c(0.5, 9.5),
    labels = c("Fewer doctors", "More doctors")) +
  labs(title = title, subtitle = st, caption = cap) +
  facet_wrap(~label) +
  theme_void(base_size = 7, base_family = body_font) +
  theme(
    plot.margin = margin(10, 10, 10, 10),
    plot.background = element_rect(
      fill = bg_col, color = bg_col),
    panel.background = element_rect(
      fill = bg_col, color = bg_col),
    plot.title = element_textbox_simple(
      color = text_col,
      lineheight = 0.5),
    plot.subtitle = element_textbox_simple(
      color = text_col,
      lineheight = 0.5),
    plot.caption = element_textbox_simple(
      hjust = 0,
      color = text_col,
      lineheight = 0.5),
    strip.background = element_rect(
      fill = highlight_col, color = highlight_col)
  )
styled_plot
```

move subtitle text 

::: {.callout-note icon=false appearance="simple"}

Prior to Note `legend.position.inside` used to be `legend.position` before ggplot2 3.5.0

legend ticks

:::

```{r}
#| label: fig-doctors-style-plot-5
#| fig-cap: "caption"
styled_plot +
  labs(
    title = NULL, subtitle = NULL, tag = st
  ) +
  # add space for the tag (subtitle) text
  coord_sf(ylim = c(-60, 140)) +
  theme(
    # move and format the tag (subtitle) text
    plot.margin = margin(0, 0, 5, 0),
    plot.tag.position = c(0.015, 0.8),
    plot.tag = element_textbox_simple(
      color = text_col,
      lineheight = 0.5,
      hjust = 0,
      maxwidth = 0.98
    ),
    # add margin for caption
    plot.caption = element_textbox_simple(
      hjust = 0,
      color = text_col,
      margin = margin(l = 5),
      lineheight = 0.5),
    # change title text color
    strip.text = element_textbox_simple(
      color = bg_col,
      lineheight = 0.5,
      size = rel(1.4),
      face = "bold",
      margin = margin(6, 5, 6, 5)
    ),
    # legend text
    legend.title = element_blank(),
    legend.text = element_text(
      color = text_col,
      lineheight = 0.5,
      hjust = 0.5
    ),
    # legend size
    legend.key.width = unit(1, "cm"),
    legend.key.height = unit(0.2, "cm"),
    # legend position
    legend.position = "bottom",
    legend.justification.bottom = "right",
    legend.margin = margin(0, 20, -4, 0), 
    legend.direction = "horizontal",
    legend.ticks = element_blank()
  )
```


## Reflection

> Note: ℹ The package "mapproj" is required for `coord_map()`.
✖ Would you like to install it? 1: Yes 2: No
didn't use in original version

When the original plot of this data was created, it plotted the number of doctors per 1,000 people over the age of 70 and the colours were based on the log of this value. The raw values on the colour scale were hard to interpret, so the choice was made to use *Fewer doctors* and *More doctors* labels instead. For this version, where the underlying data is simpler and easier to ... 

When we were processing the data, we made the choice to plot a map showing the values for the most recently available data. That means that for some countries the data is more recent (and therefore perhaps more reliable), whilst for others it's much older. In fact, running `range(doctors$year)` shows that the most recent data in the plot is from 2019, whilst the oldest is from 1980 - a gap of almost 40 years! That makes it much harder to accurately compare between countries, and there's no indication for each country on this map how recent the data is. Showing uncertainty on maps is tricky, ... perhaps setting the colours ... above or below average, with the intensity ... . Or at least a more detailed 

::: {.content-visible when-format="html"}

Each plot created during the process of developing the original version of this visualisation was captured using {camcorder}, and is shown in the gif below. If you'd like to learn more about how {camcorder} can be used in the data visualisation process, @sec-camcorder.

![](images/doctors.gif){fig-align="center"}

:::
