---
filters:
  - line-highlight
execute: 
  freeze: auto
fig-width: 5
fig-asp: 0.5
---

```{r}
#| echo: false
#| eval: true
#| file: R/options.R
```

```{r}
#| echo: false
#| eval: true
#| file: R/load_font_awesome.R
```

```{r}
#| echo: false
#| eval: true
#| file: R/social_caption.R
```

# R Packages: using images for custom facet labels {#sec-r-pkgs}

In this chapter, we'll learn about how to collect data on which packages and functions are used in R code, replacing the underlying data in a plot that's already been made, and how to use images as category labels.

## Data

All of the directories containing code for visualisation are in file based on dates in the following structure: `yyyy/yyyy-mm-dd/yyyymmdd.R`. Since it takes a while to run, let's it to code for visualisations created in `2023`. We can use `str_detect()` from {stringr} to find any ... in the `relative_paths` column that contain `"2023"` and then `filter()` from {dplyr} to keep only those rows.  \index{stringr!str\_detect}

see [@streamline].

```{r}
#| label: r-pkgs-load-data-1
#| eval: false
#| echo: true
files_to_check <-
  funspotr::list_files_github_repo("nrennie/tidytuesday",
    branch = "main"
  ) |>
  dplyr::filter(stringr::str_detect(relative_paths, "2023"))
```

Then pass intp `spot_funs_files()` from {funspotr} [@funspotr]

```{r}
#| label: r-pkgs-load-data-2
#| eval: false
#| echo: true
r_funs <- files_to_check |>
  funspotr::spot_funs_files(
    show_each_use = TRUE,
    keep_in_multiple_pkgs = TRUE
  )
```

got a few errors here, maybe try re-running or debugging

We then use the `unnest_results()` function from {funspotr} to get a row in the data for each use of the package. Since the code above takes a while to run, it's also important that we save the data in a format that means we can use it later (rather than having to re-download it). We'll save it as a CSV file using `write.csv()`, choosing an appropriate file name and removing the row names. \index{funspotr!unnest\_results} \index{utils!write.csv}

```{r}
#| label: r-pkgs-load-data-3
#| eval: false
#| echo: true
r_pkgs <- rfuns |>
  funspotr::unnest_results()
write.csv(r_pkgs, "data/r_pkgs.csv", row.names = FALSE)
```

We can then read the CSV back in using `read_csv()` from {readr} at any ... (or `read.csv()` if you prefer!) \index{readr!read\_csv}

```{r}
#| label: r-pkgs-load-data-csv
#| output: false
r_pkgs <- readr::read_csv("data/r_pkgs.csv")
```

## Exploratory work

### Data exploration

\index{base!sort}

```{r}
#| label: fig-r-pkgs-barplot
#| fig-cap: "Plot"
#| fig-asp: 1
barplot(
  sort(table(r_pkgs$pkgs)),
  # make labels smaller so they fit on the page
  cex.axis = 0.5,
  cex.names = 0.5,
  las = 1,
  horiz = TRUE
)
```

(base R + tidyverse) is better than base R or tidyverse

\index{dplyr!mutate} \index{dplyr!case\_when}

```{r}
#| label: r-pkgs-pkgs
r_pkgs <- r_pkgs |>
  dplyr::mutate(
    pkgs = dplyr::case_when(
      pkgs == "ggplot" ~ "ggplot2",
      TRUE ~ pkgs
    )
  )
```


### Exploratory sketches

![Initial sketches of a faceted area charts showing packages use over time](images/sketch-packages-1.png){#fig-packages-sketch-1 fig-align="center"}

Replace 

![Initial sketches of a faceted area charts showing packages use over time, with hex stickers instead of text labels](images/sketch-packages-2.png){#fig-packages-sketch-2 fig-align="center"}

## Preparing a plot

### Data wrangling

We're going to focus on the [core {tidyverse}](https://www.tidyverse.org/packages/#core-tidyverse) packages [@tidyverse]

```{r}
#| label: r-pkgs-core
core_tidyverse <- c(
  "dplyr", "forcats", "ggplot2", "purrr",
  "readr", "stringr", "tibble", "tidyr"
)
```

We use 

\index{dplyr!filter} \index{tidyr!separate\_wider\_delim} \index{dplyr!mutate} \index{dplyr!count} \index{lubridate!ymd}


```{r}
#| label: r-pkgs-date
r_pkgs_date <- r_pkgs |>
  dplyr::filter(pkgs %in% core_tidyverse) |>
  tidyr::separate_wider_delim(
    relative_paths,
    delim = "/",
    names = c(NA, "date", NA)
  ) |>
  dplyr::mutate(date = lubridate::ymd(date)) |>
  dplyr::count(date, pkgs)
```


\index{dplyr!summarise} \index{dplyr!arrange} \index{dplyr!pull}

or use `desc()` \index{dplyr!desc}

```{r}
#| label: r-pkgs-orders
pkgs_ordered <- r_pkgs_date |>
  dplyr::summarise(n = sum(n), .by = pkgs) |>
  dplyr::arrange(-n) |>
  dplyr::pull(pkgs)
pkgs_ordered
```

\index{dplyr!mutate} \index{base!factor}

notice that tibble is missing

```{r}
#| label: r-pkgs-levels
pkgs_levels <- c(
  pkgs_ordered,
  setdiff(core_tidyverse, pkgs_ordered)
)
plot_data <- r_pkgs_date |>
  dplyr::mutate(
    pkgs = factor(pkgs, levels = pkgs_levels)
  )
```

or use desc



### Packages and functions

### The first plot

\index{ggplot2!ggplot} \index{ggplot2!geom\_area} \index{ggplot2!aes} \index{ggplot2!facet\_wrap}

We set `drop = FALSE` to allow the {tibble}

```{r}
#| label: fig-r-pkgs-base-plot-1
#| fig-cap: "Plot"
#| warning: true
library(ggplot2)
base_plot <- ggplot(plot_data) +
  geom_area(
    mapping = aes(
      x = date,
      y = n,
      fill = pkgs
    )
  ) +
  facet_wrap(~pkgs, nrow = 1, drop = FALSE)
base_plot
```

get a warning

You'll also notice there's one week 141 times. I double checked this data and it is actually correct

misleading - stringr and readr have same number of uses, but it looks like stringr is used significantly more - 0 is not included
forcats has only one use - but represented 0 times since 

\index{tidyr!complete}

```{r}
#| label: r-pkgs-new-data
new_plot_data <- plot_data |>
  tidyr::complete(
    date, pkgs,
    fill = list(n = 0)
  )
```

\index{utils!head}

```{r}
#| label: r-pkgs-head-new
head(new_plot_data, n = 8)
```

notice that tibble now included as well

updating data set on plot, could just rerun

```{r}
#| label: fig-r-pkgs-base-plot-2
#| fig-cap: "Plot"
base_plot <- base_plot %+% new_plot_data
base_plot
```

## Advanced styling

### Colours

[@rcartocolor]

\index{rcartocolor!carto\_pal}

```{r}
#| label: r-pkgs-cols
bg_col <- "#3A3B3C"
text_col <- "white"
col_palette <- rcartocolor::carto_pal(9, "Bold")[1:8]
highlight_col <- col_palette[1]
```

\index{ggplot2!scale\_fill\_manual}

```{r}
#| label: fig-r-pkgs-col-plot
#| fig-cap: "Plot"
col_plot <- base_plot +
  scale_fill_manual(
    values = col_palette,
    drop = FALSE
  )
col_plot
```

### Fonts

Similar to @sec-programming, since code is the subject of the visualisation, we might want to choose a font that's consistent with that theme. Here we'll use *Source Code Pro*, a monospace font family originally designed specifically for coding environments. It's loaded into R using `font_add_google()` from {sysfonts}.

In this chapter, we'll use the same font for the title and body text so we only need to define one variable, `body_font`. \index{sysfonts!font\_add\_google} \index{showtext!showtext\_auto} \index{showtext!showtext\_opts}

```{r}
#| label: r-pkgs-fonts
sysfonts::font_add_google(
  name = "Source Code Pro",
  family = "source"
)
showtext::showtext_auto()
showtext::showtext_opts(dpi = 300)
body_font <- "source"
```

### Adding text

As we've done in previous chapters, we'll use the `social_caption()` function we defined in @sec-cats to create a caption containing Font Awesome icons with social media handles: \index{social\_caption}

```{r}
#| label: r-pkgs-social
social <- social_caption(
  bg_color = bg_col,
  icon_color = highlight_col,
  font_color = text_col,
  font_family = body_font
)
```

, ... quote from the ... [... website]() in italics using `*`.

We also join together the subtitle text, data source information, and social media caption using `paste0()` (although you could use `glue()` instead). \index{base!paste0}

```{r}
#| label: r-pkgs-text
title <- "How many times did I use {tidyverse} packages for TidyTuesday?"
st <- "The tidyverse is a collection of open source R packages that *share an underlyingdesign philosophy, grammar, and data structures of tidy data*. Of the 8 core tidyverse packages, {ggplot2} was my most used package for TidyTuesday visualisations in 2023."
cap <- paste0(
  st,
  "<br>**Data**: github.com/nrennie/tidytuesday<br>**Graphic**:",
  social
)
```

We can then pass this text into the `labs()` function to apply it to our plot. We also set `x = ""` to remove the x-axis text, and define a more informative y-axis title. \index{ggplot2!labs}

```{r}
#| label: r-pkgs-text-plot
text_plot <- col_plot +
  labs(
    title = title,
    subtitle = cap,
    x = "",
    y = "Number of package calls"
  )
```

::: {#tip-packages-axis .callout-tip}

## Removing axis titles

There are multiple different ways to remove the axis labels. You can set `x = ""` as we've done here, or `x = NULL`. You can also set `axis.text.x = element_blank()` inside `theme()` to remove the text. \index{ggplot2!theme} \index{ggplot2!element\_theme}

:::

### Adjusting themes

We .. process text 

\index{ggplot2!scale\_x\_date} \index{ggplot2!scale\_y\_continuous} \index{ggplot2!coord\_cartesian} \index{lubridate!ymd}


```{r}
#| label: fig-r-pkgs-limits-plot
#| fig-cap: "Plot"
limits_plot <- text_plot +
  scale_x_date(
    limits = c(
      lubridate::ymd(20230101), lubridate::ymd(20231231)
    ),
    breaks = c(
      lubridate::ymd(20230101), lubridate::ymd(20230701)
    ),
    labels = c("Jan", "Jul")
  ) +
  scale_y_continuous(
    limits = c(0, 150),
    breaks = c(0, 50, 100, 150)
  ) +
  coord_cartesian(expand = F)
limits_plot
```

\index{ggplot2!theme\_dark} \index{ggplot2!theme} \index{ggplot2!element\_rect} \index{ggplot2!element\_text} \index{grid!unit} \index{ggplot2!element\_blank} \index{ggplot2!element\_line} \index{ggtext!element\_textbox\_simple}

```{r}
#| label: fig-r-pkgs-theme-plot
#| fig-cap: "Plot"
theme_plot <- limits_plot +
  theme_dark(
    base_size = 6,
    base_family = body_font
  ) +
  theme(
    legend.position = "none",
    plot.margin = margin(5, 10, 5, 10),
    # plot background
    plot.background = element_rect(
      fill = bg_col, colour = bg_col
    ),
    panel.background = element_rect(
      fill = bg_col, colour = bg_col
    ),
    # facet strip text and background
    strip.background = element_rect(
      fill = bg_col, colour = bg_col
    ),
    strip.text = element_text(
      face = "bold"
    ),
    panel.spacing = unit(0.5, "lines"),
    # title and subtitle text
    plot.title.position = "plot",
    plot.title = ggtext::element_textbox_simple(
      colour = text_col,
      hjust = 0,
      halign = 0,
      margin = margin(b = 5, t = 5),
      face = "bold",
      size = rel(1.4)
    ),
    plot.subtitle = ggtext::element_textbox_simple(
      colour = text_col,
      hjust = 0,
      halign = 0,
      margin = margin(b = 5, t = 0)
    ),
    # axes styling and grid lines
    axis.text = element_text(
      colour = text_col
    ),
    axis.title = element_text(
      colour = text_col
    ),
    axis.ticks = element_blank(),
    panel.grid.major = element_line(
      colour = alpha(text_col, 0.2),
      linewidth = 0.2
    ),
    panel.grid.minor = element_line(
      colour = alpha(text_col, 0.3),
      linewidth = 0.2
    )
  )
theme_plot
```

## Using images as facet labels

As we saw in @sec-lemurs, packages such as {ggimage} [@ggimage] or {ggtextures} [@ggtextures] can be used to plot images within the plotting area. Here, we want to use images outside of the plotting area in the facet labels. There are several options for overlaying images on existing plots (including outside of the main plot area). The `inset_element()` function from {patchwork} [@patchwork] can add elements on top of existing plots (we'll see an example in @sec-time-zones). Similarly, `draw_image()` function from {cowplot} [@cowplot] simplifies the process of combining plots and images. However, to edit the facet labels we don't actually need any additional packages beyond the ones we've already used to make the plot. 

We've used the {ggtext} package [@ggtext] many times already to add styling through the use of both Markdown and HTML syntax. For example, we added lines breaks using `<br>` and colored text using `<span></span>`. The `<img>` tag is used to add images in HTML. So let's use that in combination with {ggtext} to format the facet labels!

Before we get started, we need to get some images! The hex stickers for many R packages can be found at [github.com/rstudio/hex-stickers](https://github.com/rstudio/hex-stickers). For each of the 8 packages included in the plot, we can download the relevant hex sticker and **save it somewhere sensible**. Here, we'll save each image as a PNG file and the name of the file is the same as the name of the package e.g. the hex sticker for {dplyr} is saved as `dplyr.png`. To keep our directories looking clean and tidy, we might choose to save them in a folder. Here, we'll save them in a nested folder: `images/hex/`. This means the (relative) file path for our {dplyr} hex sticker is `images/hex/dplyr.png`. This is what we want to pass in as the image source in the `<img>` HTML tag for the {dplyr} facet label.

This means we need to make two edits to our data:

* including `<img>` tags in the `pkgs` column that is used as the faceting variable.
* including `<img>` tags in the factor levels of the `pkgs` column to keep the correct ordering.

Let's start with the factor levels. Currently, the factor levels are just the package names. Luckily, we've been smart enough to save the images with the package name as the file name. This means we can use `glue()` from the {glue} package to stick together the package names with the HTML code. Let's pass in the `pkgs_levels` vector we created earlier in to the end of the image file path, to create a new vector for the factor levels: \index{glue!glue}

```{r}
#| label: r-pkgs-new-levels-1
new_levels <- glue::glue(
  "<img src='images/hex/{pkgs_levels}.png'>"
)
```

We can also control how the images appear within the `<img>` tag (to some extent). For example, we can set the width of the image (this will take a little bit of trial and error!). The images will be left-aligned by default within the facet label area and, unfortunately, the `hjust` arguments don't seem to affect the image. Instead, we can use a slightly *hacky* solution and add some blank space to the left hand side. In HTML, `&nbsp;` can be used to add a (non-breaking) space. Again, a little bit of trial and error is needed to figure out how many spaces we need to add.

```{r}
#| label: r-pkgs-new-levels-2
new_levels <- glue::glue(
  "&nbsp;&nbsp;&nbsp;&nbsp;<img src='images/hex/{pkgs_levels}.png' width='20'>"
)
```

Now we need to do the same thing to the `pkgs` column. It's important that we overwrite the `pkgs` column here rather than making an entirely new column. This means that we can use the `%+%` operator to update the data and the ...

\index{dplyr!mutate} \index{glue!glue} \index{base!factor}

```{r}
#| label: r-pkgs-img-data
plot_img_data <- new_plot_data |>
  dplyr::mutate(
    pkgs = glue::glue("&nbsp;&nbsp;&nbsp;&nbsp;<img src='images/hex/{pkgs}.png' width='20'>")
  ) |>
  dplyr::mutate(
    pkgs = factor(pkgs, levels = new_levels)
  )
```

As we did earlier, let's update the data to use our new `plot_img_data` using the `%+%` operator:

```{r}
#| label: r-pkgs-img-plot
img_plot <- theme_plot %+% plot_img_data
```

We also need to tell {ggplot2} that the facet labels are using HTML tags, just as we've done with the caption. We edit the `theme()` function further and update the styling for `strip.text.x`. We again use `element_textbox_simple()` from {ggtext}, but don't need to pass in any further arguments since everything is controlled through the HTML tags. \index{ggplot2!theme} \index{ggtext!element\_textbox\_simple}

```{r}
#| label: fig-r-pkgs-final-plot
#| fig-cap: "Plot"
img_plot +
  theme(
    strip.text.x = ggtext::element_textbox_simple(),
  )
```

::: {#tip-packages-axis .callout-tip}

## Facet label images using {marquee}

You can do a very similar thin

:::

## Reflection

Maybe using a log transformation of the y-axis would make it easier to see the very small values - although log transformations do have their own downsides in terms of interpretability. 

importance of explcitly capturing 0 (implicitly not good)
implicit/explicit missing data - does it mean 0 

The use of color could also be improved here. The colors are used to denote the different packages, and so don't provide any further information not already given by the facet labels - similar to what we discussed in @sec-museums. A single color for all area plots would provide the same amount of information, but look a little bit less distracting. If we did still want to use different colors, we may consider matching them more closely to the colors in the hex sticker images. For example, the green in the {stringr} hex sticker image is quite similar to the green used in the {dplyr} area chart - this might be a little bit confusing. 

::: {.content-visible when-format="html"}

## The making of...

Each plot created during the process of developing the original version of this visualisation was captured using {camcorder}, and is shown in the gif below. If you'd like to learn more about how {camcorder} can be used in the data visualisation process, see @sec-camcorder.

![](images/r-pkgs.gif){fig-align="center"}

:::
