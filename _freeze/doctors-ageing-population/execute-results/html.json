{
  "hash": "8f03c1afd588b79aaaf4d8e9033d9f7e",
  "result": {
    "engine": "knitr",
    "markdown": "---\nfig-width: 5\nfig-asp: 0.67\nfig-align: center\nfig-dpi: 300\nfilters:\n  - line-highlight\nexecute: \n  freeze: auto\n---\n\n\n# Doctors in an ageing population: making maps with {ggplot2} {#doctors}\n\nIn this chapter we'll learn how to identify open data sources, make maps with {ggplot2} using data from the {maps} package, and create title panels with an unorthodox use of facets.\n\n## Data \n\nThere's often a *Bring Your Own Data* week each year of \\#TidyTuesday\\index{TidyTuesday} [@tidytuesday], where participants are encouraged to source their own data. Some use their own data - visualising how many times they've gone for a run over the past year, or recreating GitHub contributions graphs. Others choose to find and visualise other sources of data. So where do you find publicly available data?\n\nThere are many open sources of data, covering a wide range of topics, time frames, and regions across the world. Some government organisations have data portals, some compaies have APIs you can access, some academic papers have accompanying data, or the Google dataset search engine ([datasetsearch.research.google.com](https://datasetsearch.research.google.com/)) might also help you to identify data you're interested in.\n\nOne fantastic source of data is the Our World in Data website ([ourworldindata.org](https://ourworldindata.org/)). The aim of Our World in Data, according to their website, is to *publish the research and data to make progress against the world’s largest problems*. There are datasets on everything from energy and environment, to poverty and education, to name a few. Their website also has many examples of beautiful, effective data visualisations if you're ever looking for inspiration.\\index{Our World in Data}\n\nFor this chapter, we'll visualise data on [Medical doctors per 1,000 people](https://ourworldindata.org/grapher/physicians-per-1000-people),  a dataset which comes from the Our World in Data website [@doctors_data].\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndoctors <- readr::read_csv(\"data/doctors.csv\")\n```\n:::\n\n\n\\index{readr!read\\_csv}\n\n## Exploratory work\n\nLet's start by exploring the data to see if there are interesting patterns that can be visualised. \n\n### Data exploration\n\nThe data is reasonably small, containing only 4 columns: `entity` (denoting the country or a larger region), `code` (the country code), `year` (year the data relates to), and `Physicians (per 1,000 people)`. The 4682 rows of data cover 221 different regions (some aggregates of others), with data covering `r `length(unique(doctors$year))` years.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(doctors)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  entity      code   year `Physicians (per 1,000 people)`\n  <chr>       <chr> <dbl>                           <dbl>\n1 Afghanistan AFG    1960                           0.035\n2 Afghanistan AFG    1965                           0.063\n3 Afghanistan AFG    1970                           0.065\n4 Afghanistan AFG    1981                           0.077\n5 Afghanistan AFG    1986                           0.183\n6 Afghanistan AFG    1987                           0.179\n```\n\n\n:::\n:::\n\n\nOften when there's a time component to data, one of the most obvious patterns to consider is how other variables change over time. Although line charts are probably most common for visualising time series data, a simple scatter plot can also indicate if there's a general trend in the data. Sometimes scatter plots also look cleaner than line charts - a line for each region in this chart would very much look like a *spaghetti chart* as discussed in @sec-museums.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(\n  x = doctors$year,\n  y = doctors$`Physicians (per 1,000 people)`,\n  xlab = \"Year\", ylab = \"Physicians per 1,000 people\")\n```\n\n::: {.cell-output-display}\n![](doctors-ageing-population_files/figure-html/doctors-base-plot-1.png){width=1500}\n:::\n:::\n\n\nThere seems to be a general increasing trend between 1960 and 2019. The other important component of this data that we may want to explore is the spatial aspect - is there a pattern over space as well as over time? The most common approach to visualising spatial data is, of course, to plot it on a map. If the aim is to show how a variable changes across different countries (or other defined regions), it's very common to color the country based on the value of the variable. These are often termed *choropleth maps*.\\index{choropleth map}\n\n### Exploratory sketches\n\n![](images/sketch-doctors.png){#fig-doctors-sketch fig-align=\"center\" fig-cap=\"Initial sketch of a map of the world\"}\n\nAt this point, it's also often a good time to start thinking about the orientation and aspect ratio of the plot you'll create. This will depend a lot of where the plot is going to end up - for example, plots in a single column academic article will typically be landscape graphs. The choice of orientation and aspect ratio can also affect how clearly your data is displayed - choosing a very wide plot for time series data can stretch the series and obliterate any appearance of trend. With maps, you're a little bit more constrained because there is already an underlying aspect ratio in the plot you're creating. For this map, a landscape orientation with a 6x4 aspect ratio should work reasonably well. \\index{aspect ratio} \\index{orientation}\n\n## Preparing a plot\n\nTo create the map sketched out in @fig-doctors-sketch, we need to do two things (i) decide which data to plot: which regions, and which years; and (ii) source some spatial data beyond just region names and country codes.\n\n### Data wrangling\n\nSince this data is already fairly tidy, there isn't too much data wrangling to be done. The only processing we really need to do is getting rid of the data we don't need, and renaming a couple of columns to make them easier to work with. We can use the `rename()` function from {dplyr} to rename the `entity` column to `region` (for reasons that will become clear in the next paragraph!)\\index{dplyr!rename}. We also rename the `Physicians (per 1,000 people)` column to `doctors` to make it easier to work with. The data has multiple entries for each country, spanning different years. We *could* make an animated map to show how the number of doctors is changing over time, but for now we'll keep it simple with a static map showing a snapshot at one point in time. However, there's a bit of a problem. If you inspect the data, you'll see that not every country has an entry for each year - let's use the most recent data available for each country. For each `region`, we keep the row with only the most recent year using a combination of `group_by()`\\index{dplyr!group\\_by} and `slice_max()`\\index{dplyr!slice\\_max} from {dplyr}.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndoctors <- doctors |>\n  dplyr::rename(\n    region = entity,\n    doctors = `Physicians (per 1,000 people)`) |>\n  dplyr::select(region, year, doctors) |>\n  dplyr::group_by(region) |>\n  dplyr::slice_max(year) |>\n  dplyr::ungroup()\n```\n:::\n\n\nTo plot this data on a world map, we also need data for the country borders. Luckily, the `map_data()` function built into {ggplot2}\\index{ggplot2!map\\_data} can help us with that! This function takes data from the {maps} package\\index{maps} and turns it into an object you can plot directly with {ggplot2}.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nworld <- map_data(\"world\")\n```\n:::\n\n\nOf course, it's never quite that straightforward. We need to join the `world` map data to our `doctors` data, and to do that we need a column in each data sets to join by - we'll use the `region` column. If you try to join these two data sets using the `region` column, you'll notice that you end up with some unexpected `NA` values. So what's going on?\n\n> You don't need to rename columns in your data to be able to join them, but for this example, I found it a little bit easier to work with the data after renaming `entity` to `region`.\n\nThere are two issues here. Firstly, there are more regions in the `world` data than there are in the `doctors` data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(unique(world$region))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 252\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(unique(doctors$region))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 221\n```\n\n\n:::\n:::\n\n\nThis is partly due to the fact that the `doctors` data has implicitly missing values - if no data is available for a region, no rows exists in the data for that region. It isn't listed with `NA` values. Note that there are also some *regions* in `doctors` which do not exist in `world` - for example, the entity `\"Upper-middle-income countries\"` is listed within `doctors`.\n\nSecondly, if you inspect the region names, you'll see that for some countries, their names are encoded differently. For example, in the `world` data, the United States is listed as `\"USA\"` whilst in the `doctors` data, it's listed as `\"United States\"`. Here, the easiest thing to do is manually rename the values that differ in one of the datasets. We can use the `recode()` function from {dplyr} to do that.\\index{dplyr!recode} Note that `recode()` has the rather unusual (for the {tidyverse}) syntax of `old_name = new_name`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_data <- doctors |>\n  dplyr::mutate(\n    region =\n      dplyr::recode(region,\n        \"United Kingdom\" = \"UK\",\n        \"United States\" = \"USA\",\n        \"Congo, Dem. Rep.\" = \"Democratic Republic of the Congo\",\n        \"Cote d'Ivoire\" = \"Ivory Coast\",\n        \"Congo, Rep.\" = \"Republic of Congo\")\n  )\n```\n:::\n\n\n\\index{dplyr!left\\_join} and filter out Antarctica \\index{dplyr!filter}\n\nThe entries in `region` column of `doctors` that don't correspond to countries e.g. `\"Upper-middle-income countries\"` are not values that are required for the map. Therefore a left join can be performed, with `world` on the left - keeping all the countries listed in `world` and joining only those with a corresponding value in `doctors`. The remaining countries in `world` with no match in `doctors` are listed with `NA` values. The rows for `\"Antarctica\"` are filtered out - Antractica is often given a disproportionate amount of space on world maps (at least those not centered on Antarctica) in the process of projecting a sphere onto a rectangle.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_data <- dplyr::left_join(world, plot_data, by = \"region\") |>\n  dplyr::filter(region != \"Antarctica\")\n```\n:::\n\n\nNow, we have everything we need to create a simple map.\\index{map}\n\n### The first plot\n\nWe start, as almost always, with the `ggplot()` function, and pass in the data and aesthetic mappings that will apply to the whole plot. The longitude (`long`) and latitude (`lat`) are passed to the `x` and `y` axes; and we specify that the `fill` color of each country should be based on the `doctors` column. We also specify `map_id` - aesthetic mapping that isn't seen as often as the others. This is used to tell `geom_map()` which column defines (not entirely unlike the `group` aesthetic discussed in previous chapters). \\index{ggplot2!geom\\_map}\\index{ggplot2!aes}\n\nBoth `geom_sf()` and `geom_map()` are used for creating maps within {ggplot2}. However, they expect different formats of data: `geom_sf()` expects an `sf` object, whereas `geom_map()` works with coordinates as columns in a `data.frame` or `tibble`. Here, we'll use `geom_map()`. For examples of using `geom_sf()`, see Chapter ??. \\index{ggplot2!geom\\_map}\\index{ggplot2!geom\\_sf}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_plot <- ggplot(\n  data = map_data,\n  mapping = aes(\n    x = long,\n    y = lat,\n    map_id = region,\n    fill = doctors)) +\n  geom_map(map = map_data)\nbase_plot\n```\n\n::: {.cell-output-display}\n![Map of the world with countries colored based on number of doctors per 1,000 people. The map looks stretched.](doctors-ageing-population_files/figure-html/fig-doctors-basic-plot-1-1.png){#fig-doctors-basic-plot-1 width=1500}\n:::\n:::\n\n\nSo we have a simple map that shows our data, but there are several problems with it: \n\n* The map looks as if someone was stretched in vertically, since there's no map projection specified. Countries are still recognisable, but not quite the right shape.\n* The color palette is not ideal. It's more intuitive for brighter or lighter colors to represent smaller values, and for darker colors to represent higher values - at least for light colored backgrounds [@Schloss]. The default gradient color scale in {ggplot2} is the opposite way around.\n* There are labels that don't need to be there (`lat` and `long`), and missing labels that should be there (`title` and `subtitle`, for example).\n\nSo let's fix those elements of the initial plot.\n\n## Advanced styling\n\nWe'll start by considering alternative color palettes, then think about text that should be added, before finalising the layout. \n\n### Colors\n\nThere are many, many colour palette R packages in existence, and even more outwith the R ecosystem. In fact, the {paletteer} package\\index{paletteer} is designed give a common interface to a comprehensive collection of color palettes in R. One of my favourite is color palette R packages is \\index{MetBrewer} [@MetBrewer] - a collection of color palettes inspired by works of art at the Metropolitan Museum of Art in New York. It has many beautiful palettes, and many that work in traditional data visualisations. You can view all available palettes using `MetBrewer::display_all(colorblind_only = TRUE)`. Since `doctors` is a continuous variable, we'll look at the sequential palettes only.\n\n{MetBrewer} does have functions that interface directly with {ggplot2} (such as `scale_fill_met_c()`) but we're going to use some of the colors in the palette to also define variables for the highlight and text colors. To get a good range of colors, we extract 20 colors from the `\"Hokusai2\"` palette. The `text_col` is the 18th color and `highlight_col` is the 15th color. A variable containing the background color, `bg_col`, is also defined.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(MetBrewer)\ncol_palette <- met.brewer(\"Hokusai2\", n = 20)\ntext_col <- col_palette[18]\nhighlight_col <- col_palette[15]\nbg_col <- \"#EADEDA\"\n```\n:::\n\n\nThese colors can then be passed into `scale_fill_gradientn()` from {ggplot2}\\index{ggplot2!scale\\_fill\\_gradientn}. The limits of the color scale can also be set. Rather than adding labels for values on the legend, we can add text labels for *Fewer doctors* and *More doctors*. These are position 0.5 in from the limits of the color scale.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncol_plot <- base_plot +\n  scale_fill_gradientn(\n    colors = col_palette,\n    limits = c(0, 10),\n    breaks = c(0.5, 9.5),\n    labels = c(\"Fewer doctors\", \"More doctors\"))\ncol_plot\n```\n\n::: {.cell-output-display}\n![Map of the world with countries colored based on number of doctors per 1,000 people, showing a different color scheme.](doctors-ageing-population_files/figure-html/fig-doctors-style-plot-1-1.png){#fig-doctors-style-plot-1 width=1500}\n:::\n:::\n\n\n### Text and fonts\n\nNow, we can define some text for the title, subtitle, and caption. As in previous chapters, we'll be using {ggtext} for formatting which means we can use markdown syntax to add bold font and line breaks.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntitle <- \"Doctors in an ageing population\"\nst <- \"This map show the number of doctors per thousand people, revealing which countries* may be more likely to struggle in providing care for a population.<br><br>*using the most recent available data for each country.\"\ncap <- \"**Data**: Our World in Data | **Graphic**: N. Rennie\"\n```\n:::\n\n\nThese text variables can then be passed into the `labs()` function in {ggplot2}\\index{ggplot2!labs}:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntext_plot <- col_plot +\n  labs(title = title, subtitle = st, caption = cap)\n```\n:::\n\n\nFonts can also be defined using the {sysfonts}\\index{sysfonts} and {showtext}\\index{showtext} packages. Here, the *Roboto* font is loaded through Google Fonts. \\index{sysfonts!font\\_add\\_google} \\index{showtext!showtext\\_auto} \\index{showtext!showtext\\_opts}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsysfonts::font_add_google(name = \"Roboto\", family = \"roboto\")\nshowtext::showtext_auto()\nshowtext::showtext_opts(dpi = 300)\nbody_font <- \"roboto\"\n```\n:::\n\n\nTo apply these fonts to the plot, the `theme` elements need to be adjusted. \\index{ggplot2!theme}\n\n### Adjusting themes\n\nWe start by adding `theme_void()` from {ggplot2}. The `theme_void` function removes all `theme` elements - including grid lines, axis labels, and the background. The legend and specified titles and subtitles remain. This theme is especially useful for maps where it's more common for axis lines, axis titles, and grid lines not to be displayed. Like other built-in theme options, we can still set the `base_size` and `base_family` to set the default size and font family for any text that is displayed. \\index{ggplot2!theme\\_void}\n\nWe also set the `plot.title`, `plot.subtitle`, and `plot.caption` to use `element_textbox_simple` from {ggtext} to allow the markdown syntax and automatically wrap long subtitles as we've seen in previous chapters.\\index{ggtext!element\\_textbox\\_simple}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggtext)\ntext_plot +\n  theme_void(base_size = 8, base_family = body_font) +\n  theme(\n    plot.margin = margin(10, 10, 10, 10),\n    plot.background = element_rect(\n      fill = bg_col, color = bg_col),\n    panel.background = element_rect(\n      fill = bg_col, color = bg_col),\n    plot.title = element_textbox_simple(\n      color = text_col),\n    plot.subtitle = element_textbox_simple(\n      color = text_col),\n    plot.caption = element_textbox_simple(\n      hjust = 0,\n      color = text_col)\n  )\n```\n\n::: {.cell-output-display}\n![Map of the world with countries colored based on number of doctors per 1,000 people. Styling ...](doctors-ageing-population_files/figure-html/fig-doctors-style-plot-3-1.png){#fig-doctors-style-plot-3 width=1500}\n:::\n:::\n\n\nOne of the ...\nBox for title facets\n\n\n\\index{ggplot2!facet\\_wrap}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_data$label <- title\n```\n:::\n\n\nWhile we're here, let's lines of map same color as bg and a little bit thinner\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstyled_plot <- ggplot(\n  data = map_data,\n  mapping = aes(\n    long,\n    lat,\n    map_id = region,\n    fill = doctors)) +\n  geom_map(\n    map = map_data,\n    color = bg_col,\n    linewidth = 0.3) +\n  scale_fill_gradientn(\n    colors = col_palette,\n    limits = c(0, 10),\n    breaks = c(0.5, 9.5),\n    labels = c(\"Fewer doctors\", \"More doctors\")) +\n  labs(title = title, subtitle = st, caption = cap) +\n  facet_wrap(~label) +\n  theme_void(base_size = 7, base_family = body_font) +\n  theme(\n    plot.margin = margin(10, 10, 10, 10),\n    plot.background = element_rect(\n      fill = bg_col, color = bg_col),\n    panel.background = element_rect(\n      fill = bg_col, color = bg_col),\n    plot.title = element_textbox_simple(\n      color = text_col,\n      lineheight = 0.5),\n    plot.subtitle = element_textbox_simple(\n      color = text_col,\n      lineheight = 0.5),\n    plot.caption = element_textbox_simple(\n      hjust = 0,\n      color = text_col,\n      lineheight = 0.5),\n    strip.background = element_rect(\n      fill = highlight_col, color = highlight_col)\n  )\nstyled_plot\n```\n\n::: {.cell-output-display}\n![caption](doctors-ageing-population_files/figure-html/fig-doctors-style-plot-4-1.png){#fig-doctors-style-plot-4 width=1500}\n:::\n:::\n\n\nmove subtitle text \n\n::: {.callout-note icon=false appearance=\"simple\"}\n\nPrior to Note `legend.position.inside` used to be `legend.position` before ggplot2 3.5.0\n\nThe other difference is that we can set `legend.ticks = element_blank()` to remove the white tick marks inside the colorbar legend.\n\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstyled_plot +\n  labs(\n    title = NULL, subtitle = NULL, tag = st\n  ) +\n  # add space for the tag (subtitle) text\n  coord_sf(ylim = c(-60, 140)) +\n  theme(\n    # move and format the tag (subtitle) text\n    plot.margin = margin(0, 0, 5, 0),\n    plot.tag.position = c(0.015, 0.8),\n    plot.tag = element_textbox_simple(\n      color = text_col,\n      lineheight = 0.5,\n      hjust = 0,\n      maxwidth = 0.98),\n    # add margin for caption\n    plot.caption = element_textbox_simple(\n      hjust = 0,\n      color = text_col,\n      margin = margin(l = 5),\n      lineheight = 0.5),\n    # change title text color\n    strip.text = element_textbox_simple(\n      color = bg_col,\n      lineheight = 0.5,\n      size = rel(1.4),\n      margin = margin(6, 5, 6, 5)),\n    # legend text\n    legend.title = element_blank(),\n    legend.text = element_text(\n      color = text_col,\n      lineheight = 0.5,\n      hjust = 0.5),\n    # legend size\n    legend.key.width = unit(1.2, \"cm\"),\n    legend.key.height = unit(0.2, \"cm\"),\n    # legend position\n    legend.position = \"bottom\",\n    legend.justification.bottom = \"right\",\n    legend.margin = margin(0, 20, -4, 0),\n    legend.direction = \"horizontal\",\n    legend.ticks = element_blank()\n  )\n```\n\n::: {.cell-output-display}\n![caption](doctors-ageing-population_files/figure-html/fig-doctors-style-plot-5-1.png){#fig-doctors-style-plot-5 width=1500}\n:::\n:::\n\n\n\n## Reflection\n\nWhen the original plot of this data was created, it plotted the number of doctors per 1,000 people over the age of 70 and the colors were based on the log of this value - compare @fig-doctors-style-plot-5 and @fig-doctors-original. The raw values on the color scale were hard to interpret, so the choice was made to use *Fewer doctors* and *More doctors* labels instead. For this version, where the underlying data is simpler and easier to interpret, having the values on the legend would add more useful information. The original title was also kept, but could probably be changed to something more informative.\n\n![](images/doctors_original.png){#fig-doctors-original fig-align=\"center\"}\n\nWhen the data was processed, the choice was made to plot a map showing the values for the most recently available data. This means that for some countries the data is more recent (and therefore perhaps more reliable), whilst for others it's much older. In fact, running `range(doctors$year)` shows that the most recent data in the plot is from 2019, whilst the oldest is from 1980 - a gap of almost 40 years! That makes it much harder to accurately compare between countries, and there's no indication for each country on this map how recent the data is. Readers might end up drawing conclusions that show differences between countries, when actually the different is between times. Showing uncertainty on maps is tricky, and there's no straightforward solution here. Perhaps setting the colors to a binary scale showing whether he value is above or below average, with the intensity of the color denoting the recentness of the data, is one approach. Or at least a more detailed explanation about the range of time the data relates to could be included within the subtitle.\n\nOne improvement to this map over the original is the use of `coord_sf()`\\index{ggplot2!coord\\_sf} to *correctly* scale the aspect ratio of the map. In the original map, using `coord_map()` (now deprecated in favour of `coord_sf()`) produced some odd looking results, and in the end, after applying the rest of the styling changes, the end result didn't look too squashed. But `coord_sf()` made it much easier to achieve.\n\n::: {.content-visible when-format=\"html\"}\n\nEach plot created during the process of developing the original version of this visualisation was captured using {camcorder}, and is shown in the gif below. If you'd like to learn more about how {camcorder} can be used in the data visualisation process, @sec-camcorder.\n\n![](images/doctors.gif){fig-align=\"center\"}\n\n:::\n",
    "supporting": [
      "doctors-ageing-population_files\\figure-html"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}