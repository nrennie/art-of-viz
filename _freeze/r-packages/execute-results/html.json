{
  "hash": "8febed368f6e5c21db70dc5c2f2a3f1b",
  "result": {
    "engine": "knitr",
    "markdown": "---\nfilters:\n  - line-highlight\nexecute: \n  freeze: auto\nfig-width: 5\nfig-asp: 0.5\n---\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n# R Packages: using images for custom facet labels {#sec-r-pkgs}\n\nIn this chapter, we'll learn about how to collect data on which packages and functions are used in R code, replacing the underlying data in a plot that's already been made, and how to use images as category labels.\n\n## Data\n\nIn July 2024, TidyTuesday [@tidytuesday] featured some examples of using the {funspotr} package [@funspotr] as datasets. The {funspotr} package was designed to help identify which R functions and packages are used in files and projects. Let's try to identify which R functions and packages have been used in this GitHub repository of TidyTuesday visualisations: [github.com/nrennie/tidytuesday](https://github.com/nrennie/tidytuesday). \n\nLet's start by getting a list of all the files that exist in the GitHub repository. We can use the `list_files_github_repo()` function from {funspotr} to get this list of files - specifying which GitHub repository we want the list for (in the form of `\"username/repository\"`), and which branch of the repository we want to look at. The `list_files_github_repo()` function returns a data frame with two columns: `relative_paths` (file path relative to the root of the git repository) and `absolute_paths` (URL of each file). \\index{funspotr!list\\_files\\_github\\_repo}\n\nAll of the files in this repository are named and organised based on dates in the following structure: `yyyy/yyyy-mm-dd/yyyymmdd.R` [@streamline]. Since the code to extract used functions takes a while to run, let's filter this list of files to only include files dated `2023`. We can use `str_detect()` from {stringr} to find any values in the `relative_paths` column that contain `\"2023\"` and then `filter()` from {dplyr} to keep only those rows.  \\index{stringr!str\\_detect} \\index{dplyr!filter}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfiles_to_check <- funspotr::list_files_github_repo(\n  repo = \"nrennie/tidytuesday\",\n  branch = \"main\"\n) |>\n  dplyr::filter(stringr::str_detect(relative_paths, \"2023\"))\n```\n:::\n\n\nWe then pass the `files_to_check` data frame into `spot_funs_files()` from {funspotr} to get the list of functions and packages uses in each file. Since we want to look at total package use, we set `show_each_use = TRUE` to make sure that individual rows are returned each time a function is used (rather than just once for an entire file). \\index{funspotr!spot\\_funs\\_files}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr_funs <- files_to_check |>\n  funspotr::spot_funs_files(\n    show_each_use = TRUE\n  )\n```\n:::\n\n\nWe then use the `unnest_results()` function from {funspotr} to get a row in the data for each use of a function. Since the code above takes a while to run, it's also important that we save the data in a format that means we can use it later (rather than having to re-download it). We'll save it as a CSV file using `write.csv()`, choosing an appropriate file name and removing the row names. \\index{funspotr!unnest\\_results} \\index{utils!write.csv}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr_pkgs <- rfuns |>\n  funspotr::unnest_results()\nwrite.csv(r_pkgs, \"data/r_pkgs.csv\", row.names = FALSE)\n```\n:::\n\n\nWe can then read the CSV back in using `read_csv()` from {readr} (or `read.csv()` if you prefer!) \\index{readr!read\\_csv}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr_pkgs <- readr::read_csv(\"data/r_pkgs.csv\")\n```\n:::\n\n\nThe `r_pkgs` data has 4059 rows and 4 columns. The `funs` column contains names of each function used, and `pkgs` has the name of the package that function comes from. The remaining two columns are the `relative_paths` and `absolute_paths` columns that identify which file the function was found in. Let's have a quick look at the data using `head()`: \\index{utils!head}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(r_pkgs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  funs            pkgs    relative_paths\n  <chr>           <chr>   <chr>         \n1 library         base    2023/2023-01-…\n2 library         base    2023/2023-01-…\n3 library         base    2023/2023-01-…\n4 library         base    2023/2023-01-…\n5 font_add_google sysfon… 2023/2023-01-…\n6 font_add_google sysfon… 2023/2023-01-…\n# ℹ 1 more variable:\n#   absolute_paths <chr>\n```\n\n\n:::\n:::\n\n\n## Exploratory work\n\nThe obvious question to start with here is: which packages are used most often?\n\n### Data exploration\n\nLet's start by counting the number of package uses with the `table()` function, and using `sort()` to arrange packages from least to most used. \\index{base!table} \\index{base!sort}\n\nWe can then pass this into the `barplot()` function to obtain an ordered bar chart of package use - setting `horiz = TRUE` to make a horizontal bar chart. Since there is a large number of bars, we also adjust the labels to be a little smaller. We can see that `ggplot` comes out on top, closely followed by `base`! \n\n> As an aside, this highlights that combining base R and {tidyverse} packages can be incredibly effective since they each have different strengths. There's no need to choose a side on the base R versus {tidyverse} argument - use both!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbarplot(\n  sort(table(r_pkgs$pkgs)),\n  # make labels smaller so they fit on the page\n  cex.axis = 0.5,\n  cex.names = 0.5,\n  las = 1,\n  horiz = TRUE\n)\n```\n\n::: {.cell-output-display}\n![Ordered bar chart showing the number of times each package was used in 2023. The 'ggplot2' package is used most.](r-packages_files/figure-html/fig-r-pkgs-barplot-1.png){#fig-r-pkgs-barplot}\n:::\n:::\n\n\nOne thing that you may have noticed is that, for some reason, in the data the package is listed as `\"ggplot\"` rather than `\"ggplot2\"`. So let's fix that using `mutate()` and the `if_else()` function from {dplyr}. We can overwrite the existing `pkgs` column, where (i) if the value is currently `\"ggplot\"`, we replace it with `\"ggplot2\"`; (ii) otherwise, we leave the existing value in the `pkgs` column. \\index{dplyr!mutate} \\index{dplyr!if\\_else}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr_pkgs <- r_pkgs |>\n  dplyr::mutate(\n    pkgs = dplyr::if_else(\n      pkgs == \"ggplot\",\n      \"ggplot2\",\n      pkgs\n    )\n  )\n```\n:::\n\n\n### Exploratory sketches\n\nThere are currently 38 packages listed in the data, many of them with one or two uses. That's quite a lot of categories to visualize at once, so let's narrow it down to only the [core {tidyverse}](https://www.tidyverse.org/packages/#core-tidyverse) packages [@tidyverse]. We could visualise a simple bar chart (or variation of a bar chart) showing how often each core {tidyverse} package was used. But due to the structure of the file names, we also have information about *when* each package was used. So we could visualize usage over time, for each package. \n\nFor each package, we could create an area (or line) chart showing usage over time using facets as we did in @sec-museums. This time, the categories don't really have a natural order, so instead we'll order the facets from most to least used. It might look something like this:\n\n![Initial sketch of a faceted area charts showing packages use over time](images/sketch-packages-1.png){#fig-packages-sketch-1 fig-align=\"center\"}\n\nOne of the most incredible things about the R community, is our adoration of hex stickers - package logos in the shape of a hexagon. All of the core {tidyverse} packages have their own hex sticker. Rather than simply using the package name as the facet label in our plot, we could replace the labels with images of hex stickers:\n\n![Initial sketch of a faceted area charts showing packages use over time, with hex stickers instead of text labels](images/sketch-packages-2.png){#fig-packages-sketch-2 fig-align=\"center\"}\n\n## Preparing a plot\n\nTo prepare an initial draft of the plot in @fig-packages-sketch-1, we need to wrangle the following information from the data:\n\n* The date each package use relates to (currently embedded in a file name);\n* The number of package uses per day for each core {tidyverse} package; and \n* Which package was used the most often?\n\n### Data wrangling\n\nSince we're going to focus on the core {tidyverse} packages, let's start by making a vector of the package names:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncore_tidyverse <- c(\n  \"dplyr\", \"forcats\", \"ggplot2\", \"purrr\",\n  \"readr\", \"stringr\", \"tibble\", \"tidyr\"\n)\n```\n:::\n\n\nWe can then use this vector to `filter()` the data and keep only rows where the `pkgs` column has a value in the `core_tidyverse` vector. \\index{dplyr!filter} \n\nThe `relative_paths` are currently of the form `\"yyyy/yyyy-mm-dd/yyyymmdd.R\"`, and we want to extract the date from this file path. There are multiple ways of doing this - the easiest way is to extract the part of the file path that is between the two `/`. You could use functions from the {stringr} package [@stringr], which is designed for processing character strings. But we can alternatively make use of `separate_wider_delim()` from {tidyr}. This function allows you to separate a character string in one column, into multiple columns based on some delimiter. In this case, the delimiter will be `/`. By default, this will create three new columns for each section of the string: `yyyy`, `yyyy-mm-dd`, and `yyyymmdd.R`. We only want to keep the middle one, so we can use the trick of setting the names of columns we don't want to keep to `NA`. Instead, we'll create only one new column called `date`. \\index{tidyr!separate\\_wider\\_delim} \\index{stringr}\n\nWe also convert the `date` which is currently still a character string into a date object using `mutate()` and the `ymd()` function from {lubridate} (since the dates are specified in **y**ear, **m**onth, **d**ay format). Finally, we count how many observations there are of each package, per date. \\index{dplyr!mutate} \\index{dplyr!count} \\index{lubridate!ymd}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr_pkgs_date <- r_pkgs |>\n  dplyr::filter(pkgs %in% core_tidyverse) |>\n  tidyr::separate_wider_delim(\n    relative_paths,\n    delim = \"/\",\n    names = c(NA, \"date\", NA)\n  ) |>\n  dplyr::mutate(date = lubridate::ymd(date)) |>\n  dplyr::count(date, pkgs)\n```\n:::\n\n\nWe want the facets in our plot to be ordered from most to least used package. so let's calculate the total number of uses for each package. Here, we can use the `summarise()` function in {dplyr}, to add up the values in the `n` column, split by `pkgs`. Here, we're using the `.by` argument in `summarise()` but you could alternatively use `group_by(pkgs)` instead. We then arrange the rows of the data based on the updated summary `n` column. By default `arrange()` sorts in ascending order, so to sort in descending order we simply sort by `-n` instead. You could alternatively use `dplyr::desc(n)`. Finally, we extract the `pkgs` column as a vector using `pull()` from {dplyr}. \\index{dplyr!summarise} \\index{dplyr!arrange} \\index{dplyr!pull} \\index{dplyr!desc} \\index{dplyr!group\\_by}\n\n\n::: {.cell}\n\n```{.r .cell-code}\npkgs_ordered <- r_pkgs_date |>\n  dplyr::summarise(n = sum(n), .by = pkgs) |>\n  dplyr::arrange(-n) |>\n  dplyr::pull(pkgs)\npkgs_ordered\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"ggplot2\" \"dplyr\"   \"readr\"  \n[4] \"stringr\" \"tidyr\"   \"purrr\"  \n[7] \"forcats\"\n```\n\n\n:::\n:::\n\n\nWhat might strike you about this vector of ordered packages is that there are only 7 packages listed. If you look closely, you'll notice that `\"tibble\"` is missing. It's missing because it's never been used directly - that's not that surprising, since it's often used in the background of the other {tidyverse} packages. The question now is, should it still be included in the chart? Sometimes, it's important to visualise zeroes. So how do we add it `tibble` into the data?\n\nThe first thing we want to do is include it in the ordered list of packages that we'll later use to define a factor level. Since it's only one package, we *could* just manually add it to the end of the vector with `c(pkgs_ordered, \"tibble\")`. However, this isn't a very robust solution. If we had data for a different year and wanted to repeat this analysis, this code wouldn't work if `\"tibble\"` wasn't missing, or if another package was missing. \n\nLet's find a generalisable way to figure out which core {tidyverse} packages are not included in the `pkgs_ordered` vector. We can use the `setdiff()` function from base R here. Running `setdiff(x, y)` tells you which elements of `x` are not in `y` (so it's important to get the choices of `x` and `y` the right way around). \n\nThe difference in the two vectors (in this case `\"tibble\"`) can then be appended to the end of the `pkgs_ordered` vector, to create a complete list of packages in order from most to least used, including zero usage:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npkgs_levels <- c(\n  pkgs_ordered,\n  setdiff(core_tidyverse, pkgs_ordered)\n)\n```\n:::\n\n\nThen, we use `mutate()` to convert the `pkgs` column of our data from a character string to a factor (ordered category) and set he `levels` equal to our new `pkgs_levels` vector: \\index{dplyr!mutate} \\index{base!factor}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_data <- r_pkgs_date |>\n  dplyr::mutate(\n    pkgs = factor(pkgs, levels = pkgs_levels)\n  )\n```\n:::\n\n\nNow we're ready to create a first draft of @fig-packages-sketch-1!  \n\n### The first plot\n\nWe start our plot by passing `plot_data` into `ggplot()` to use this data as the base for all elements in the plot. We then add `geom_area()` to create the geometry for the area chart, specifying the aesthetic mapping using `aes()` again. We put the `date` on the x-axis, `n` on the y-axis. and set the fill color of the area chart based on the category in `pkgs`. This is very similar to the initial plots created in @sec-museums. \\index{ggplot2!ggplot} \\index{ggplot2!geom\\_area} \\index{ggplot2!aes} \n\nWe then add `facet_wrap()` to create small multiple plots, split by `pkgs`. We want our facet plots all in one line rather than arranged as a grid, so we set `nrow = 1` inside `facet_wrap()`. Although `\"tibble\"` is a level in our `pkgs` factor column, no observations of that factor level exist. To make sure it still appears as an (empty) facet, we set `drop = FALSE`. Otherwise, only 7 faceted plots would be shown. \\index{ggplot2!facet\\_wrap}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'ggplot2' was built\nunder R version 4.4.1\n```\n\n\n:::\n\n```{.r .cell-code}\nbase_plot <- ggplot(plot_data) +\n  geom_area(\n    mapping = aes(\n      x = date,\n      y = n,\n      fill = pkgs\n    )\n  ) +\n  facet_wrap(~pkgs, nrow = 1, drop = FALSE)\nbase_plot\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in min(diff(unique_loc)): no\nnon-missing arguments to min; returning\nInf\n```\n\n\n:::\n\n::: {.cell-output-display}\n![Faceted area charts showing package use over time for each of the 8 core {tidyverse} packages, with facets ordered from most to least use. The ordering doesn't quite look correct.](r-packages_files/figure-html/fig-r-pkgs-base-plot-1-1.png){#fig-r-pkgs-base-plot-1}\n:::\n:::\n\n\nYou might notice two things here:\n\n* alongside the plot, a (slightly confusing) warning message is returned;\n* the ordering of the plot doesn't look quite right.\n\nYou might also notice the large spike in the {ggplot2} facet which shows 141 uses of the {ggplot2} package in a single script and wonder if this is an error. It's not an error - it was actually used that many times!\n\nLet's start by thinking about the second one of these issues and see if we can figure out what's happening. We've specified that the facets should be ordered from most to least used in total. But the area for the {stringr} package looks much larger than the area for the {readr} package - even though it should be smaller. It also looks as though there are no values in the {forcats} facet - but we know this isn't true for {forcats}, only for {tibble}. Why is this happening?\n\nThe problem is that 0 is not included in the data. The areas are being drawn between only the strictly positive values, never going back down to 0. For packages that are used a lot but only in a few scripts, this makes their area larger than packages that are used once or twice in many scripts.\n\nIn our data set, if a package isn't used in a script, there is no entry in the data. This makes sense since there are tens of thousands of packages and it would be much more difficult and time consuming to list every package that isn't used, rather than just those that are. But in our case, these missing, unobserved values aren't really missing values - they are 0 values. \n\nThe warning message returned from the plot is also trying to tell us about this problem (the warning just isn't very clear!)\n\n::: {#tip-packages-area .callout-tip}\n\n## Don't ignore the warning signs!\n\nThis *is it a zero or is it missing?* question has highlighted a few important aspects of plotting charts and data processing:\n\n* Don't simply ignore warning messages if you don't understand them. It might be tempting to ignore the warning message because you ended up with a plot that looks kind of like what you expected, and the warning message isn't very clear about what's wrong. But here, the warning was telling us that something was wrong with our assumptions about the data.\n\n* Ordering your data (sensibly) can help you to spot issues. If the facets hadn't been ordered, it would have been harder to recognize that some area were overestimated, and some were underestimated.\n\n* Sometimes missing values are explicitly represented as `NA` values (or something else), and other times missing values are simply rows that do not exist in the data. We often think about missing values more when we see them as `NA` values. But just because you have no `NA` values in your data, doesn't mean that you don't have any missing values.\n\n* When you have missing values (whether explicit or implicit), it's important to think about why they are missing and whether they are really missing. Does a missing values mean 0? Or does it mean it's actually missing? Or does it mean something else entirely? It's important to understand the process of data collection to answer this question correctly.\n\n:::\n\nLet's go ahead and add in zeros where they should be. We know that the `date` and `pkgs` columns are complete: there are no missing values in the `date` column and we've already addressed the issue with the missing `\"tibble\"` values. We need to make sure that every possible combination of `date` and `pkgs` exists in the data: any that do not already exist should be added and given a value of `0` in the `n` column.\n\nWe can use the `complete()` function from {tidyr} to *complete* the data. We pass in the `date` and `pkgs` columns to say which combinations of columns we need to make sure exist. By default, missing combinations are represented by `NA`, but we can override the `fill` argument to use `0` instead. \\index{tidyr!complete}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_plot_data <- plot_data |>\n  tidyr::complete(\n    date, pkgs,\n    fill = list(n = 0)\n  )\n```\n:::\n\n\nLet's take a quick look at our updated data using `head()` to make sure this has worked: \\index{utils!head}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(new_plot_data, n = 8)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 × 3\n  date       pkgs        n\n  <date>     <fct>   <int>\n1 2023-01-03 ggplot2    24\n2 2023-01-03 dplyr       9\n3 2023-01-03 readr       2\n4 2023-01-03 stringr     0\n5 2023-01-03 tidyr       3\n6 2023-01-03 purrr       0\n7 2023-01-03 forcats     0\n8 2023-01-03 tibble      0\n```\n\n\n:::\n:::\n\n\nWe can see that there are now quite a few `0` values included in the `n` column. Notice that `\"tibble\"` is now explicitly included as well, with `0` in the `n` column for all observations. This is because, by default, `complete()` uses all levels of the factor even if they aren't observed in the data.\n\nNow we need to update the data that is used in our `base_plot`. We *could* simply edit (or copy and paste) the code from above and substitute `plot_data` for `new_plot_data`. But we can alternatively use the `%+%` operator.\n\nThe `%+%` operator allows you to replace the current default data frame on an existing plot. We start with our existing `base_plot`, and then use `%+%` to set `new_plot_data` as the data used in the plot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_plot <- base_plot %+% new_plot_data\nbase_plot\n```\n\n::: {.cell-output-display}\n![Faceted area charts showing package use over time for each of the 8 core {tidyverse} packages, with facets ordered from most to least use. The ordering now looks correct.](r-packages_files/figure-html/fig-r-pkgs-base-plot-2-1.png){#fig-r-pkgs-base-plot-2}\n:::\n:::\n\n\nNotice that the warning message has now disappeared.\n\n## Advanced styling\n\nNow that we have a first draft of the plot, it's time to work on polishing it. We'll make some adjustments to the colors, fonts, text, scales, and themes - before we move on to editing the facets labels to create a visualisation like @fig-packages-sketch-2.\n\n### Colors\n\nLet's go for a dark theme for our plot this time. We'll choose a dark grey for the background color, and white for the text to ensure sufficient contrast.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbg_col <- \"#3A3B3C\"\ntext_col <- \"white\"\n```\n:::\n\n\nLet's also define a color palette that we'll use for the fill color of the area charts. As we did in @sec-turbines, we'll use one of th palettes in {rcartocolor} [@rcartocolor]. As we did in @sec-turbines, to avoid the gray color, we ask for one more color than we need and then throw away the gray color. We have 8 categories in our plot, so we ask for 9 colors using the `carto_pal()` function and then extract only the first 8. We'll use the `\"Bold\"` palette here. \\index{rcartocolor!carto\\_pal}\n\nTo keep a more consistent color theme in the plot, we define our highlight color variable, `highlight_col`, to be the first color in our chosen color palette.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncol_palette <- rcartocolor::carto_pal(\n  length(core_tidyverse) + 1, \"Bold\"\n)[1:length(core_tidyverse)]\nhighlight_col <- col_palette[1]\n```\n:::\n\n\nWe can then pass this `col_palette` vector into `scale_fill_manual()` function to apply the colors to our plot: \\index{ggplot2!scale\\_fill\\_manual}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncol_plot <- base_plot +\n  scale_fill_manual(\n    values = col_palette\n  )\ncol_plot\n```\n\n::: {.cell-output-display}\n![Faceted area charts showing package use over time for each of the 8 core {tidyverse} packages. Each area chart is colored using a different color from the {rcartocolor} package.](r-packages_files/figure-html/fig-r-pkgs-col-plot-1.png){#fig-r-pkgs-col-plot}\n:::\n:::\n\n\n### Fonts\n\nSimilar to @sec-programming, since code is the subject of the visualisation, we might want to choose a font that's consistent with that theme. Here we'll use *Source Code Pro*, a monospace font family originally designed specifically for coding environments. It's loaded into R using `font_add_google()` from {sysfonts}.\n\nIn this chapter, we'll use the same font for the title and body text so we only need to define one variable, `body_font`. \\index{sysfonts!font\\_add\\_google} \\index{showtext!showtext\\_auto} \\index{showtext!showtext\\_opts}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsysfonts::font_add_google(\n  name = \"Source Code Pro\",\n  family = \"source\"\n)\nshowtext::showtext_auto()\nshowtext::showtext_opts(dpi = 300)\nbody_font <- \"source\"\n```\n:::\n\n\n### Adding text\n\nAs we've done in previous chapters, we'll use the `social_caption()` function we defined in @sec-cats to create a caption containing Font Awesome icons with social media handles: \\index{social\\_caption}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsocial <- social_caption(\n  bg_color = bg_col,\n  icon_color = highlight_col,\n  font_color = text_col,\n  font_family = body_font\n)\n```\n:::\n\n\nThe subtitle includes a quote from the [{tidyverse} website](https://www.tidyverse.org/), so we'll format it in italics using `*`. We also use the `source_caption()` function we defined in @sec-turbines to create a caption with information about the data source, combined with the social icons to attribute the graphic. \\index{source\\_caption}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntitle <- \"How many times did I use {tidyverse} packages for TidyTuesday?\"\nst <- \"The tidyverse is a collection of open source R packages that *share an underlying design philosophy, grammar, and data structures*. Of the 8 core tidyverse packages, {ggplot2} was my most used package for TidyTuesday visualisations in 2023.\"\nsource_cap <- source_caption(\n  source = \"github.com/nrennie/tidytuesday\",\n  graphic = social,\n  sep = \"<br>\"\n)\n```\n:::\n\n\nWe also join together the subtitle text with the data and graphic source information using `paste0()` (although you could use `glue()` instead). \\index{base!paste0}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncap <- paste0(st, \"<br>\", source_cap)\n```\n:::\n\n\nWe can then pass this text into the `labs()` function to apply it to our plot. We also set `x = \"\"` to remove the x-axis text, and define a more informative y-axis title. \\index{ggplot2!labs}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntext_plot <- col_plot +\n  labs(\n    title = title,\n    subtitle = cap,\n    x = \"\",\n    y = \"Number of package calls\"\n  )\n```\n:::\n\n\n::: {#tip-packages-axis .callout-tip}\n\n## Removing axis titles\n\nThere are multiple different ways to remove the axis labels. You can set `x = \"\"` as we've done here, or `x = NULL`. You can also set `axis.text.x = element_blank()` inside `theme()` to remove the text. \\index{ggplot2!theme} \\index{ggplot2!element\\_theme}\n\n:::\n\n### Adjusting scales and themes\n\nWe can adjust the x- and y- axes labeling to deal with the over-crowding of the labels. By default, labels have been added on each facet, at every three months. Although the data only covers 2023, {ggplot2} also extends the x-axis to cover the beginning of 2024. We can adjust the `limits` and `breaks` of the x-axis scale to show only 2023, and have fewer labels. Since the values on the x-axis are dates, we use `scale_x_date()` to make the adjustments. This also means that the values we pass into the `breaks` and `limits` arguments of `scale_x_date()` should be dates, and so we again make use of `ymd()` from {lubridate}. We set the x-axis limits to be from January 1 to December 31 of 2023, and add labels on the first of January and July. \\index{ggplot2!scale\\_x\\_date} \\index{lubridate!ymd}\n\nFor the y-axis, we choose *nice* limits and breaks - setting the limits to between 0 and 150, with breaks every 50. To remove the excess space around the edge of each facet plot, we also set `expand = FALSE` in `coord_cartesian()`. \\index{ggplot2!coord\\_cartesian} \n\\index{ggplot2!scale\\_y\\_continuous} \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlimits_plot <- text_plot +\n  scale_x_date(\n    limits = lubridate::ymd(c(\"20230101\", \"20231231\")),\n    breaks = lubridate::ymd(c(\"20230101\", \"20230701\")),\n    labels = c(\"Jan\", \"Jul\")\n  ) +\n  scale_y_continuous(\n    limits = c(0, 150),\n    breaks = c(0, 50, 100, 150)\n  ) +\n  coord_cartesian(expand = FALSE)\nlimits_plot\n```\n\n::: {.cell-output-display}\n![Faceted area charts showing package use over time for each of the 8 core {tidyverse} packages. A title and subtitle has been added but runs of the page. However, the x-axis labels no longer overlap.](r-packages_files/figure-html/fig-r-pkgs-limits-plot-1.png){#fig-r-pkgs-limits-plot}\n:::\n:::\n\n\nLet's edit the arguments of `theme()` to finalist out plot. There's a fairly large number of adjustments to make, so we'll do them in two stages.  \\index{ggplot2!theme}\n\nWe'll start by setting the default font family and base font size in the `text` argument through `element_text()`. We also remove the legend and add a little bit of space around the edges of the plot using the `margin()` function. \\index{ggplot2!element\\_text} \\index{ggplot2!margin} \\index{grid!unit}\n\nWe then edit the `plot.background` and `panel.background` to have the background color we defined earlier (as `bg_col`) by using the `fill` and `color` arguments in `element_rect()`. We also do the same for the facet label background which is controlled by the `strip.background` argument. Although we're planning to replace the facet labels with images, for now we'll format them with bold text in our preferred color. The spacing between the facets is controlled by the `panel.spacing` argument. \\index{ggplot2!element\\_rect} \\index{ggplot2!element\\_text} \\index{ggplot2!unit}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninit_theme_plot <- limits_plot +\n  theme(\n    text = element_text(family = body_font, size = 6),\n    legend.position = \"none\",\n    plot.margin = margin(5, 10, 5, 10),\n    # plot background\n    plot.background = element_rect(\n      fill = bg_col, color = bg_col\n    ),\n    panel.background = element_rect(\n      fill = bg_col, color = bg_col\n    ),\n    # facet strip text and background\n    strip.background = element_rect(\n      fill = bg_col, color = bg_col\n    ),\n    strip.text = element_text(\n      face = \"bold\",\n      color = text_col\n    ),\n    panel.spacing = unit(0.5, \"lines\")\n  )\n```\n:::\n\n\nOur final adjustments include specifying that we're using {ggtext} for the title and subtitle to allow the HTML and Markdown text to be processed correctly. We do this by using `element_textbox_simple()` from {ggtext} in the `plot.title` and `plot.subtitle` arguments, where we also set the font `color`, left-align it, and add a little padding around the edges. The title text is made slightly larger than normal by using the `rel()` function in size. Setting `plot.title.position = \"plot\"` means that the title and subtitle text is aligned with the edge of the whole plot, rather than the edge of the first facet plot. This gives a cleaner looker and avoids extra white created due to the width of the y-axis text. \\index{ggplot2!rel} \\index{ggplot2!theme} \\index{ggtext!element\\_textbox\\_simple}\n\nWe also make sure that the x- and y-axes labels and title are the correct color using `element_text()`. Finally, the grid lines are made thinner and semi-transparent using the `color` and `linewidth` arguments in `element_line()`. The minor grid lines are made a little bit more transparent than the major grid lines. \\index{ggplot2!element\\_line} \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntheme_plot <- init_theme_plot +\n  theme(\n    # title and subtitle text\n    plot.title.position = \"plot\",\n    plot.title = ggtext::element_textbox_simple(\n      color = text_col,\n      hjust = 0,\n      halign = 0,\n      margin = margin(b = 5, t = 5),\n      face = \"bold\",\n      size = rel(1.4)\n    ),\n    plot.subtitle = ggtext::element_textbox_simple(\n      color = text_col,\n      hjust = 0,\n      halign = 0,\n      margin = margin(b = 5, t = 0)\n    ),\n    # axes styling and grid lines\n    axis.text = element_text(\n      color = text_col\n    ),\n    axis.title = element_text(\n      color = text_col\n    ),\n    axis.ticks = element_blank(),\n    panel.grid.major = element_line(\n      color = alpha(text_col, 0.3),\n      linewidth = 0.2\n    ),\n    panel.grid.minor = element_line(\n      color = alpha(text_col, 0.1),\n      linewidth = 0.2\n    )\n  )\ntheme_plot\n```\n\n::: {.cell-output-display}\n![Faceted area charts showing package use over time for each of the 8 core {tidyverse} packages. The plot has a dark background, and white text (which no longer exceeds the plot area).](r-packages_files/figure-html/fig-r-pkgs-theme-plot-2-1.png){#fig-r-pkgs-theme-plot-2}\n:::\n:::\n\n\nThis visualisation is perfectly fine as it is, but we can still edit the facet labels to use hex stickers instead of text labels, as we proposed in @fig-packages-sketch-2.\n\n### Using images as facet labels\n\nAs we saw in @sec-lemurs, packages such as {ggimage} [@ggimage] can be used to plot images within the plotting area. Here, we want to use images outside of the plotting area in the facet labels. There are several options for overlaying images on existing plots (including outside of the main plot area). The `inset_element()` function from {patchwork} [@patchwork] can add elements on top of existing plots (we'll see an example in @sec-time-zones). Similarly, `draw_image()` function from {cowplot} [@cowplot] simplifies the process of combining plots and images. However, to edit the facet labels we don't actually need any additional packages beyond the ones we've already used to make the plot. \n\nWe've used the {ggtext} package [@ggtext] many times already to add styling through the use of both Markdown and HTML syntax. For example, we added lines breaks using `<br>` and colored text using `<span></span>`. The `<img>` tag is used to add images in HTML. So let's use that in combination with {ggtext} to format the facet labels!\n\nBefore we get started, we need to get some images! The hex stickers for many R packages can be found at [github.com/rstudio/hex-stickers](https://github.com/rstudio/hex-stickers). For each of the 8 packages included in the plot, we can download the relevant hex sticker and **save it somewhere sensible**. Here, we'll save each image as a PNG file and the name of the file is the same as the name of the package e.g. the hex sticker for {dplyr} is saved as `dplyr.png` [@hex_dplyr]. To keep our directories looking clean and tidy, we might choose to save them in a folder. Here, we'll save them in a nested folder: `images/hex/`. This means the (relative) file path for our {dplyr} hex sticker is `images/hex/dplyr.png`. This is what we want to pass in as the image source in the `<img>` HTML tag for the {dplyr} facet label.\n\nThis means we need to make two edits to our data:\n\n* including `<img>` tags in the `pkgs` column that is used as the faceting variable.\n* including `<img>` tags in the factor levels of the `pkgs` column to keep the correct ordering.\n\nLet's start with the factor levels. Currently, the factor levels are just the package names. Luckily, we've been smart enough to save the images with the package name as the file name. This means we can use `glue()` from the {glue} package to stick together the package names with the HTML code. Let's pass in the `pkgs_levels` vector we created earlier in to the end of the image file path, to create a new vector for the factor levels: \\index{glue!glue}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_levels <- glue::glue(\n  \"<img src='images/hex/{pkgs_levels}.png'>\"\n)\n```\n:::\n\n\nWe can also control how the images appear within the `<img>` tag (to some extent). For example, we can set the width of the image (this will take a little bit of trial and error!). Unfortunately, the `hjust` and `halign` arguments don't seem to fully center the image within the facet label area. Instead, we can use a slightly *hacky* solution and add some blank space to the left hand side. In HTML, `&nbsp;` can be used to add a (non-breaking) space. Again, a little bit of trial and error is needed to figure out how many spaces we need to add.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_levels <- glue::glue(\n  \"&nbsp;&nbsp;&nbsp;&nbsp;<img src='images/hex/{pkgs_levels}.png' width='20'>\"\n)\n```\n:::\n\n\nNow we need to do the same thing to the `pkgs` column. It's important that we overwrite the `pkgs` column here rather than making an entirely new column. This means that we can use the `%+%` operator to update the data and {ggplot2} will still be able to find the correct variable to facet by. We again use `glue()` to add the `pkgs` column into HTML `<img>` tags - being very careful to make sure that the new column values match exactly to the factor levels we defined in `new_levels`. This allows us to then apply these factor levels using `mutate()` to make sure the ordering of the packages from most to least used in retained. \\index{dplyr!mutate} \\index{glue!glue} \\index{base!factor}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_img_data <- new_plot_data |>\n  dplyr::mutate(\n    pkgs = glue::glue(\"&nbsp;&nbsp;&nbsp;&nbsp;<img src='images/hex/{pkgs}.png' width='20'>\")\n  ) |>\n  dplyr::mutate(\n    pkgs = factor(pkgs, levels = new_levels)\n  )\n```\n:::\n\n\nAs we did earlier, let's update the data to use our new `plot_img_data` using the `%+%` operator:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimg_plot <- theme_plot %+% plot_img_data\n```\n:::\n\n\nWe also need to tell {ggplot2} that the facet labels are using HTML tags, just as we've done with the caption. We edit the `theme()` function further and update the styling for `strip.text.x`. We again use `element_textbox_simple()` from {ggtext}, and set `hjust` and `halign` both to 0.5. \\index{ggplot2!theme} \\index{ggtext!element\\_textbox\\_simple}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimg_plot +\n  theme(\n    strip.text.x = ggtext::element_textbox_simple(\n      hjust = 0.5,\n      halign = 0.5\n    )\n  )\n```\n\n::: {.cell-output-display}\n![Faceted area charts showing package use over time for each of the 8 core {tidyverse} packages. Hex stickers have replaced the text labels on the facets.](r-packages_files/figure-html/fig-r-pkgs-final-plot-1.png){#fig-r-pkgs-final-plot}\n:::\n:::\n\n\n::: {#tip-packages-axis .callout-tip}\n\n## Facet label images using {marquee}\n\nYou can do a very similar thing using the {marquee} package [@marquee] instead of {ggtext}. The images can be added to `pkgs` using standard Markdown syntax instead of HTML tags: \\index{dplyr!mutate} \\index{glue!glue}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_img_data <- new_plot_data |>\n  dplyr::mutate(\n    pkgs = glue::glue(\"![](images/hex/{pkgs}.png)\")\n  )\n```\n:::\n\n\nRemember that you'd also need to update the factor levels and the data used in the plot. You'd then adjust the theme to use `element_marquee()` to process the Markdown syntax: \\index{marquee!element\\_marquee} \\index{ggplot2!theme}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimg_plot +\n  theme(\n    strip.text.x = marquee::element_marquee(\n      hjust = 0.5,\n      width = 1\n    )\n  )\n```\n:::\n\n\nHowever, controlling the sizing and placement of the images is (at the time of writing) a little bit more difficult with {marquee}.\n\n:::\n\n## Reflection\n\nOverall, this plot is very effective - it clearly shows the differing levels of R package use whilst still being eye-catching. However, there are still a few improvements that can be made. \n\n* Other then for {ggplot2} and {dplyr}, it's quite hard to read the values as they are very small compared to the height of the y-axis. This is due to the high usage of {ggplot2} on a single occasions. Maybe using a log transformation of the y-axis would make it easier to see the very small values - although log transformations do have their own downsides in terms of interpretability. \n\n* The use of color could also be improved here. The colors are used to differentiate the different packages, and so don't provide any further information not already given by the facet labels - similar to @sec-museums. A single color for all area plots would provide the same amount of information, but look a little bit less distracting. If we did still want to use different colors, we may consider matching them more closely to the colors in the hex sticker images. For example, the green in the {stringr} hex sticker image is quite similar to the green used in the {dplyr} area chart - this is currently a little bit distracting. \n\n::: {.content-visible when-format=\"html\"}\n\nEach plot created during the process of developing the original version of this visualisation was captured using {camcorder}, and is shown in the gif below. If you'd like to learn more about how {camcorder} can be used in the data visualisation process, see @sec-camcorder.\n\n![](images/r-pkgs.gif){fig-align=\"center\"}\n\n:::\n",
    "supporting": [
      "r-packages_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}