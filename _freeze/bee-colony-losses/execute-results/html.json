{
  "hash": "b83fda9664728680d7c41d00aa162cf0",
  "result": {
    "engine": "knitr",
    "markdown": "---\nfilters:\n  - line-highlight\nexecute: \n  freeze: auto\nfig-width: 5\nfig-asp: 1\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n# Bee Colony Losses: visualising quantities with Poisson disk sampling {#sec-bees}\n\nIn this chapter, we'll learn how to explore patterns in missing data, install R packages that aren't available on CRAN, find out how to perform Poisson disk sampling, and create plots that are faceted by two variables.\n\n## Data\n\nAs a major pollinator, bees are a vitally important part of our planet's ecosystem. However, their numbers are in decline due to factors including habitat loss, pesticide use, and diseases [Brown2009]. The United States Department of Agriculture (USDA) annually publishes data on honey bee colonies, which includes information about the number of colonies, the size of colonies, the percentage of colonies lost or added, and factors that have been identified as colony health stressors [@bees_data].\n\nThe USDA honey bee colony data was used as a TidyTuesday [@tidytuesday] data set in January 2022, and so can be loaded in using the {tidytuesdayR} package:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntuesdata <- tidytuesdayR::tt_load(\"2022-01-11\")\ncolony <- tuesdata$colony\nstressor <- tuesdata$stressor\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\nSince this version of the data is based on the 2021 release, it includes data up to June 2021. If you want to work with a more recent publication of the data, it can be obtained from [usda.library.cornell.edu/concern/publications/rn301137d](https://usda.library.cornell.edu/concern/publications/rn301137d).\n\nTwo different data sets are included. The first, `colony`, contains information about the number and size of bee colonies in each US state per year since 2015. The second, `stressor`, contains information about different sources of health stressors for bee colonies and what percentage of colonies are affected by these stressors, again for different states and time periods.\n\n## Exploratory work\n\nIn this chapter, we'll focus on the `colony` data, where we'll try to build a picture of how bee colony numbers are changing over time.\n\n### Data exploration\n\nLet's start by looking at a quick boxplot of how the number of colonies (`colony_n`) is changing over time, using the base R `boxplot()` function: \\index{graphics!boxplot}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nboxplot(\n  colony_n ~ year,\n  data = colony,\n  horizontal = TRUE,\n  xlab = \"Number of bee colonies\",\n  ylab = NULL\n)\n```\n\n::: {.cell-output-display}\n![Simple boxplot of number of bee colonies per year, showing a highly skewed distribution.](bee-colony-losses_files/figure-html/fig-bees-boxplot-1.png){#fig-bees-boxplot}\n:::\n:::\n\n\n\n\n\n\n@fig-bees-boxplot doesn't actually give us much information - except to suggest the distribution of the number of colonies is highly skewed and to suggest there are quite a few high values being classified as outliers. These outliers force the main section of the boxplots to be squashed on the left of the plot, making it difficult to tell if much is changing on average each year. This is also a more general problem with boxplots. There are many examples of data that illustrate the insufficiency of summary statistics, with Anscombe's quartet [@Anscombe1973] being perhaps the most famous example. Boxplots are essentially just summary statistics in disguise. Different data with identical boxplots can actually come from very different distributions [@Matejka2017].\n\nLet's start by trying to understand what's causing these outliers. Are they real values? Are they mistakes in the data? Or have we made an incorrect assumption about the data? To understand this a bit better, let's zoom in on one year, 2020, and look at the number of colonies in each state to understand which states the largest outliers relate to.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolony_2020 <- subset(colony, year == 2020)\nboxplot(\n  colony_n ~ state,\n  data = colony_2020,\n  horizontal = TRUE,\n  cex.axis = 0.5,\n  cex.names = 0.5,\n  las = 1,\n  xlab = \"Number of bee colonies\",\n  ylab = NULL\n)\n```\n\n::: {.cell-output-display}\n![Boxplot of the number of bee colonies per state, showing an issue with the definition of 'state'.](bee-colony-losses_files/figure-html/fig-bees-boxplot2-1.png){#fig-bees-boxplot2}\n:::\n:::\n\n\n\n\n\n\nThough there are a few states (California, Florida, and North Dakota) with a much higher number of colonies, the main issue is that one of the *states* is the entirety of the United States i.e. the sum of all of the other values. You can also see from @fig-bees-boxplot2 that not all states are included individually - an `\"Other States\"` category is also included instead which groups some states (and perhaps regions).\n\n::: {#tip-bees-names .callout-tip}\n\n## Choose appropriate column names\n\nIt's unfortunately not uncommon for a column name to suggest one thing (e.g. each value relates to a state), but for that column to actually include other values as well (e.g. a country). If you're ever naming columns (especially for data you'll share with other people) choose appropriate column names to avoid confusion. For example, `region` would be a more appropriate column name here.\n\n:::\n\nThe other aspect of our data that boxplots don't tell us about is the missingness. Boxplots only plot what's there, not what's not there. It's especially important to remember this step since base R graphics don't warn you about `NA` values in the way that {ggplot2} [@ggplot2] does. So how do we plot data that doesn't exist?\n\nThe {visdat} package [@visdat] is an excellent way to take a quick look at your data. It includes the `vis_miss()` function which, as the name suggests, allows you to get a quick visualisation of which values are missing. To avoid creating an overwhelmingly large plot, we'll start by visualising just the data for one state. We can use the `subset()` function from base R to obtain just the data fro Alabama. \\index{visdat!vis\\_miss} \\index{base!subset}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolony_AL <- subset(colony, state == \"Alabama\")\nvisdat::vis_miss(colony_AL)\n```\n\n::: {.cell-output-display}\n![](bee-colony-losses_files/figure-html/fig-bees-vismiss-1.png){#fig-bees-vismiss}\n:::\n:::\n\n\n\n\n\n\n::: {#tip-bees-vismiss .callout-tip}\n\n## Showing long column names in `vis_miss()`\n\nYou may notice that the column names in the plot generated by `vis_miss()` in @fig-bees-vismiss are rotated and this causes the right-most column name to run off the edge of the chart area. There are two solutions that can help with this problem:\n\n* Use the `abbreviate_vars()` function from {visdat} which abbreviates column names, and makes them less likely to exceed the available space.\n* Exploit the fact that the plot output from `vis_miss()` is made with {ggplot2}. This means we can use the `theme()` function to extend the space available in the plot's right margin.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\ncolony_AL |>\n  visdat::abbreviate_vars(min_length = 8) |>\n  visdat::vis_miss() +\n  theme(plot.margin = margin(r = 25))\n```\n\n::: {.cell-output-display}\n![](bee-colony-losses_files/figure-html/fig-bees-vismiss-tip-1.png){#fig-bees-vismiss-tip}\n:::\n:::\n\n\n\n\n\n\n:::\n\nIn @fig-bees-vismiss-tip, the rows are ordered in time, and you can see that there is no particular pattern appearing. The `colony_reno_pct` column has the most missing data, and that there a short time period where all data (other than the time and state) is missing. If you were to recreate this visualization for other states, you would see a similar pattern. \n\nData is unavailable for all states during the period April-June 2019. This suggests that the data is not simply randomly missing, but there was perhaps a persistent data collection issue during this time period. Though it cannot be seen in @fig-bees-vismiss-tip, there is also (implicitly) missing data for the end of the last year in the data. This is due to the time when the data is reported, with annual data releases happening in August. This means we need to be careful with taking averages across years, as data is not complete for all years.\n\nFor this chapter, we're not going to dive into methods for modelling, imputing, or removing missing values in data as that's a very big topic on its own. But whether or not you are explicitly addressing missing values, it's important to be aware of whether there are missing values, consider what aspect of the data collection processes might have caused them, and the impact this has on what conclusions you can draw.\n\nInstead, we'll limit our visualisation to a quarter for which we have complete data e.g. perhaps only looking at annual trends in the `\"January-March\"` time period, though this approach does still have its limitations. The data is recorded quarterly, so there are four options for us to choose from: `\"January-March\"`, `\"April-June\"`, `\"July-September\"`, or `\"October-December\"`. Here, we'll focus on data for `\"October-December\"`. The reason for this choice is because this time period is regarded as the start of the seasonal cycle for honey bees colonies, and the *\"condition of the colony at this time of year greatly affects its prosperity for the next year\"* [@Apiculture].\n\n::: {#tip-bees-missing .callout-tip}\n\n## Avoid missing patterns about missingness\n\nBy default, the {visdat} packages assumes that missing data is encoded as `NA`. This is not always true - especially when you're working with data that's been processed by other software before you receive it. It's not uncommon for missing values to be encoded using values such as `\"\"`, `\" \"`, `99`, `999`, `-`, or `0`. The {naniar} package [@naniar] is very useful for summarising and wrangling missing values. The `replace_with_na()` function from {naniar} can help you to replace unusual encodings of missing values with `NA` for easier data processing in R. \\index{naniar!replace\\_with\\_na}\n\nIt's also important to think about the ordering of the columns and rows when visualizing missing values. For example, if there is a column which holds a date, ordering the rows by date before visualising the missing data, will allow you to identify temporal patterns in the missingness. If the rows are ordered in some other way, you might miss this pattern.\n\n:::\n\n### Exploratory sketches\n\nFor each state, let's visualize the average number of colonies for each year. There are multiple ways we could do this: line charts or area charts are obvious first choices. Perhaps even a simple bar chart could be effective here. But let's try to be a bit more creative, and a bit more artistic, in our choice of visualization. There are many ways we could represent the number of *things* (bee colonies) in each *combination of two variables* (state and year). We have data available for every combination of state and year, so let's create a grid of states and years, as in @fig-bees-sketch-blank.\n\n![Initial sketch showing a grid of squares, with each square representing a combination of year and US state.](images/sketch-bees-blank.png){#fig-bees-sketch-blank fig-align=\"center\"}\n\nNow in each grid square, we're simply trying to show the number of *things*. How might you do that? You could draw a circle, where the size of the circle shows the number of things. Or you could color each square, where the intensity of the color shows the number of things. Or you could draw lots of points, where the number of points shows the number of things as in @fig-bees-sketch.\n\nWe might also choose to visualise only a subset of states (either focusing on states in a specific region, or simple states we're most interested in). \n\n![Initial sketch showing a grid of squares, with the number of dots representing the number of bee colonies in each year and US state.](images/sketch-bees.png){#fig-bees-sketch fig-align=\"center\"}\n\n## Preparing a plot\n\nTo bring this plot to life, we need to complete several tasks:\n\n* Calculate the average number of colonies per year, per state.\n* Simulate x- and y- coordinates for the points that will represent the number of colonies.\n* Plot the points.\n\nThis is the type of chart that has a lot of (at times complex) preparation, but the plotting itself will be relatively straightforward.\n\n### Data wrangling\n\nLet's start by selecting a subset of states to visualize:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstates_to_plot <- c(\n  \"California\", \"North Dakota\", \"Florida\",\n  \"Texas\", \"Idaho\", \"South Dakota\"\n)\n```\n:::\n\n\n\n\n\n\nWe then use the `filter()` function from {dplyr} to subset the data to only include rows for these states, and in our chosen time period of `\"October-December\"`. We also use the `select()` function to keep only the columns we actually need for our plot - the year, the state, and the number of colonies: \\index{dplyr!filter} \\index{dplyr!select}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_data <- colony |>\n  dplyr::filter(\n    state %in% states_to_plot,\n    months == \"October-December\"\n  ) |>\n  dplyr::select(\n    year, state, colony_n\n  )\n```\n:::\n\n\n\n\n\n\nBy default, the states will be ordered in alphabetical order. To make it easier to communicate patterns, we'll order the states based on the number of colonies in the final year of the data (2020). We start by determining what that order is by filtering the data to the year `2020`, arranging the data based on the `colony_n` column in a descending order (using `desc()` from {dplyr}), and then extracting the state column using `pull()`. \\index{dplyr!filter} \\index{dplyr!arrange} \\index{dplyr!desc} \\index{dplyr!pull}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstate_levels <- plot_data |>\n  dplyr::filter(year == 2020) |>\n  dplyr::arrange(dplyr::desc(colony_n)) |>\n  dplyr::pull(state)\n```\n:::\n\n\n\n\n\n\nWe'll convert the state column to a factor a little bit later, and this `state_levels` vector will provide us with the factor levels\n\nNow we need to generate the points that will represent the number of honey bee colonies in each grid square, as we sketched in @fig-bees-sketch. \n\nWe could do something simple, such as using the `runif()` function to generate `x` and `y` coordinates from a uniform distribution. However, this approach is likely to lead a plot that looks a bit messy. Randomness doesn't usually look very nice, and we would likely end up with lots of overlapping points. Instead, we want to generate points that don't overlap and are at least some minimum distance apart. To do this, we'll use *Poisson disk sampling*. \\index{Poisson disk sampling}\n\n### Poisson disk sampling with {poissoned}\n\nWe're going to use the {poissoned} package [@poissoned] to ...\n\n::: {#tip-bees-sampling .callout-tip}\n\n## Installing R packages from GitHub\n\nWhen this chapter was first written, the {poissoned} package wasn't available on CRAN, so we had to install it from GitHub instead. The {remotes} package [@remotes] can be used to install packages from remote repositories, such as GitHub or GitLab. We can use the `install_github()` function, passing in a character string of the form `\"user/repository\"`: \\index{remotes!install\\_github}\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nremotes::install_github(\"coolbutuseless/poissoned\")\n```\n:::\n\n\n\n\n\n\n:::\n\nscale with area. each point represents sqrt of 1000 bees.\nsetting random seed - reproducibility\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\nbees_grid <- plot_data |>\n  dplyr::rowwise() |>\n  dplyr::mutate(\n    pts = list(\n      poissoned::poisson2d(r = 200000 / colony_n)\n    )\n  ) |>\n  dplyr::ungroup() |>\n  tidyr::unnest(pts) |>\n  dplyr::mutate(state = factor(state, levels = state_levels))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbees_grid\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7,554 × 5\n    year state      colony_n     x     y\n   <dbl> <fct>         <dbl> <dbl> <dbl>\n 1  2015 California   750000  5.29  5.79\n 2  2015 California   750000  5.67  5.44\n 3  2015 California   750000  4.78  5.70\n 4  2015 California   750000  5.40  5.30\n 5  2015 California   750000  5.76  5.01\n 6  2015 California   750000  5.29  4.89\n 7  2015 California   750000  5.07  5.50\n 8  2015 California   750000  5.90  5.70\n 9  2015 California   750000  5.09  5.18\n10  2015 California   750000  5.60  5.93\n# ℹ 7,544 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\n::: {#tip-bees-sampling .callout-tip}\n\n## Compare uniform sampling with Poisson disk sampling\n\n\n\n\n\n\n::: {#fig-bees-sampling .cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nset.seed(123)\n# Poisson disk sampling\npts <- poissoned::poisson2d()\nplot(\n  x = pts$x, y = pts$y,\n  main = \"Poisson disk sampling\"\n)\n# Uniform sampling same number of points\nplot(\n  x = runif(nrow(pts)), y = runif(nrow(pts)),\n  main = \"Uniform sampling\"\n)\n```\n\n::: {.cell-output-display}\n![Poisson disk sampling](bee-colony-losses_files/figure-html/fig-bees-sampling-1.png){#fig-bees-sampling-1}\n:::\n\n::: {.cell-output-display}\n![Uniform sampling](bee-colony-losses_files/figure-html/fig-bees-sampling-2.png){#fig-bees-sampling-2}\n:::\n\nPoisson disk sampling and uniform sampling\n:::\n\n\n\n\n\n\nYou can see in @fig-bees-sampling\n\n:::\n\n\n### The first plot\n\nWe'll create our plot using `geom_point()` since we \n\nneed to make points very small - calif\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_plot <- ggplot(data = bees_grid) +\n  geom_point(\n    mapping = aes(x = x, y = y)\n  ) +\n  facet_grid(state ~ year, switch = \"both\")\nbase_plot\n```\n\n::: {.cell-output-display}\n![Plot](bee-colony-losses_files/figure-html/fig-bees-base-plot-1.png){#fig-bees-base-plot}\n:::\n:::\n\n\n\n\n\n\n## Advanced styling\n\n### Colors\n\nLet's select some colors for our plot. We won't be mapping any colors to columns in the data, but we still need to define a background color and a color for highlighted elements. To keep the plot looking clean, we'll also use the same color for the text. Similar to @sec-programming, we can select these colors to match the topic of the data. What colors do you think of when you think of bees? Black and yellow. We'll use black for the background color, and yellow for the highlight color. \n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbg_col <- \"#fecc27\"\nhighlight_col <- \"black\"\n```\n:::\n\n\n\n\n\n\nIf we want to ... black points against a ayellow background. We *should* update out geom_point code to\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_plot <- ggplot(data = bees_grid) +\n  geom_point(\n    mapping = aes(x = x, y = y),\n    size = 0.1,\n    color = bg_col\n  ) +\n  facet_grid(state ~ year, switch = \"both\")\nbase_plot\n```\n\n::: {.cell-output-display}\n![](bee-colony-losses_files/figure-html/unnamed-chunk-17-1.png)\n:::\n:::\n\n\n\n\n\n\n\n### Fonts\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsysfonts::font_add_google(\n  name = \"Source Code Pro\",\n  family = \"source\"\n)\nshowtext::showtext_auto()\nshowtext::showtext_opts(dpi = 300)\nbody_font <- \"source\"\n```\n:::\n\n\n\n\n\n\n### Adding text\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntitle <- \"Bee colony losses in the United States\"\nst <- \"Bees are vital for the preservation of ecological balance and biodiversity in nature. Bee populations are rapidly declining around the world due to habitat loss, pollution and the use of pesticides, among other factors. Each point represents 20,000 colonies that exist during the months of October - December each year.\"\ncap <- \"Data: USDA | Graphic: N. Rennie\"\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntext_plot <- base_plot +\n  labs(\n    title = title,\n    subtitle = st,\n    caption = cap,\n    x = NULL, y = NULL\n  )\ntext_plot\n```\n\n::: {.cell-output-display}\n![Plot](bee-colony-losses_files/figure-html/fig-bees-text-plot-1.png){#fig-bees-text-plot}\n:::\n:::\n\n\n\n\n\n\n\n### Adjusting themes\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntheme_plot <- text_plot +\n  coord_fixed(expand = FALSE) +\n  theme_void(\n    base_family = body_font,\n    base_size = 7.5\n  )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntheme_plot +\n  theme(\n    # background colors\n    plot.background = element_rect(\n      fill = bg_col, color = bg_col\n    ),\n    panel.background = element_rect(\n      fill = highlight_col, color = highlight_col\n    ),\n    strip.background = element_rect(\n      fill = bg_col,\n      color = bg_col\n    ),\n    # facet labels\n    strip.text.x = element_text(\n      color = highlight_col,\n      margin = margin(t = 5)\n    ),\n    strip.text.y = element_text(\n      color = highlight_col,\n      angle = 90,\n      margin = margin(r = 5)\n    ),\n    # text formatting\n    plot.title = ggtext::element_textbox_simple(\n      color = highlight_col,\n      face = \"bold\"\n    ),\n    plot.subtitle = ggtext::element_textbox_simple(\n      color = highlight_col,\n      margin = margin(t = 5, b = 5)\n    ),\n    plot.caption = ggtext::element_textbox_simple(\n      color = highlight_col,\n      margin = margin(t = 5)\n    ),\n    plot.margin = margin(5, 10, 5, 5)\n  )\n```\n\n::: {.cell-output-display}\n![Plot](bee-colony-losses_files/figure-html/bees-theme-plot-2-1.png)\n:::\n:::\n\n\n\n\n\n\n## Reflection\n\nThe bee-themed colors alongside the non-standard nature of this chart make it visually intriguing and fun. However, it takes a little bit more time to understand how to interpret the chart. This is a visualization that would work better in a setting where the author has time to explain how it works. For example, in a presentation or in an article with a *how to read this chart* explainer included. It would work less well in a standalone leaflet without an explanation where a reader might struggle to understand what is being shown. It's more difficult to see the trend over time with type of chart. A simple line chart could show the same data in a more *standard*, easy-to-interpret way. However, line charts don't catch attention in quite the same way. It all comes down to the purpose of the chart. Is the main aim to draw attention to important data on bee colonies, and show overall trends? Or is the main aim to communicate the colony size in each year, within some accuracy range? The answers to those questions will determine whether this is an appropriate chart type.\n\nThis version of the chart shows only data for six states, even though we know from our exploratory analysis that data is available for (almost) all states. Some explanation as to why these states have been chosen could be added in the subtitle, or data for all states could be shown - although this would result in a very long chart! The visualization also assigns each state equal chart area - perhaps implying that each state has an equal geographic area which is of course untrue. The chart shows there are a lot of bees in California. California is also the third largest state in terms of area [@UScensus] - maybe there's just more room for bees? Perhaps standardizing the data by state area (or state agricultural area) would provide an easier comparison between states. \n\nAnother disadvantage of this chart is that it visualizes only one variable - the number of bee colonies. However, even when the number of colonies is lower, if the colony sizes are larger that might mean the numbers of bees isn't changing very much. But we don't see that when we only look at the number of colonies - we don't get a full picture of the data by limiting the chart to only a single variable.\n\nAlthough this type of visualization has several disadvantages, and is far from perfect, hopefully it gives you an idea of how to think creatively about designing charts and how you might go about implementing them in R. \n",
    "supporting": [
      "bee-colony-losses_files\\figure-html"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}