---
filters:
  - line-highlight
execute: 
  freeze: true
---

# Other tips and tricks {#sec-other}

There are many functions within {ggplot2}, and many more within the wider community of extension packages, that the chapters in this book can't cover. Some of those packages are used to add different geometries, a few are used behind the scenes to help streamline workflows, and a few are more generally useful R packages.

## {camcorder} for recording gifs {#sec-camcorder}

{camcorder} [@camcorder] is an R package to track and automatically save graphics generated with {ggplot2}. You can set up your R session to use {camcorder} by running `gg_record()`. If you're using RStudio, you'll notice that your plots now appear in the *Viewer* tab rather than the *Plots* tab. \index{camcorder} \index{camcorder!gg\_record}

```{r}
#| eval: false
library(camcorder)
gg_record(
  width = 6,
  height = 4
)
```

Have you ever spent ages tinkering with a plot you’re previewing in RStudio, before using `ggsave()` to save a higher resolution image, only to end up with the text looking ridiculously larger (or smaller) than you thought? Or do you struggle to preview plots with your desired aspect ratio? One of the nice features of using {camcorder} is the ability to preview plots with the same height, width, and resolution that you want your final plot to be in. Simply set the `height`, `width`, and `dpi` (and optionally `units`) arguments in `gg_record()` to your desired values. Then what you see is what you save!

::: {#tip-other-dpi .callout-tip}

The RStudio Plots tab shows images at 96dpi, but the default in `ggsave()` is 300dpi. This is what causes the mismatch between the sizes of text and other elements. The default dpi in `gg_record()` is also 300dpi so it integrates nicely with `ggsave()`. \index{ggplot2!ggsave}

:::

If you're reading the online version of this book, you will have seen several examples of gifs showing the visualization development process at the end of chapters. The `gg_playback()` function combines the previously saved images and saves them to a gif. You can set different preferences using the arguments in `gg_playback()`. For example, you can define the length of each frame in the gif, make the first and last frames longer or shorter, or set the background color. \index{camcorder!gg\_playback}

::: {#tip-other-camcorder .callout-tip}

Some of the built-in themes in {ggplot2} have a transparent background. If you've used these at some point during the development process, when you viewed them in RStudio the background likely appeared white. The default background color in `gg_playback()` is `"black"` - meaning that your gif might not quite look as you expect. Instead set the background color to something more sensible, for example your `bg_col` variable.

:::

```{r}
#| eval: false
gg_playback(
  name = "data-viz.gif",
  first_image_duration = 4,
  last_image_duration = 20,
  frame_duration = .25,
  background = bg_col
)
```

## Code formatting with {lintr} and {styler} {#sec-code-style}

Writing code that follows a consistent style can make it easier for other people to read, makes collaboration simpler, and can help pick up code errors in your code more quickly. In R, the {lintr} package [@lintr] checks for adherence to a specified coding style and identifies possible syntax errors, then reports them so you can take action. \index{lintr}

The {styler} package [@styler] goes one step further in terms of code styling, and actually styles your code for you. Although you may be a little bit sceptical of packages that overwrite scripts you’ve written (I certainly was initially!), it makes it quick and easy to style code. Creating a keyboard shortcut for the `style_active_file()` function means you can apply code styling easily (without having to call a function manually or click a specific button). [@streamline] \index{styler!style\_active\_file}

## Template files for #TidyTuesday {#sec-template-files}

You may notice that each chapter of this book has followed a similar structure: load packages, read in some data, perform some exploratory analysis, load fonts and colors as variables, write relevant text, create a simple plot, add styling with {ggtext}, and save a PNG file. This means that for each plot, there's a lot of overlap in the structure of the .R files and the code they contain. 

If you visualise data using R on a regular basis, you'll likely find yourself repeating similar steps. You might even find yourself copying and pasting code from a previous file to your new file. Like many things in the world of programming, if you find yourself copying and pasting the same thing several times, there is almost certainly a better way of doing it. And in this case there is - template files! \index{templates}

For each \#TidyTuesday visualization, an .R script with the following file can be created [@template_files]:

```{r}
#| label: template-files
#| eval: false

date_str <- "2024-04-02"

# Load packages ----

library(tidyverse)
library(showtext)
library(patchwork)
library(camcorder)
library(ggtext)
library(glue)


# Load data ----

tuesdata <- tidytuesdayR::tt_load(date_str)


# Load fonts ----

font_add_google("Roboto", "roboto")
showtext_auto()


# Define colors and fonts ----

bg_col <- ""
text_col <- ""
highlight_col <- ""

body_font <- "roboto"
title_font <- "roboto"


# Data wrangling ----



# Start recording ----

gg_record(
  dir = file.path(date_str, "recording"),
  device = "png",
  width = 7,
  height = 5,
  units = "in",
  dpi = 300
)


# Define text ----

social <- social_caption(
  bg_color = bg_col,
  icon_color = highlight_col,
  font_color = text_col,
  font_family = body_font
)
title <- ""
subtitle <- ""
caption <- paste0(
  "**Data**: <br>**Graphic**:", social
)


# Plot ----


theme(
  plot.margin = margin(5, 5, 5, 5),
  plot.background = element_rect(
    fill = bg_col,
    color = bg_col
  ),
  panel.background = element_rect(
    fill = bg_col,
    color = bg_col
  ),
  plot.title = element_textbox_simple(
    color = text_col,
    hjust = 0.5,
    halign = 0.5,
    margin = margin(b = 10, t = 5),
    lineheight = 0.5,
    family = title_font
  ),
  plot.subtitle = element_textbox_simple(
    color = text_col,
    hjust = 0.5,
    halign = 0.5,
    margin = margin(b = 10, t = 5),
    lineheight = 0.5,
    family = body_font
  ),
  plot.caption = element_textbox_simple(
    color = text_col,
    hjust = 0.5,
    halign = 0.5,
    margin = margin(b = 5, t = 10),
    lineheight = 0.5,
    family = body_font
  )
)


# Save gif ----

gg_playback(
  name = file.path(date_str, paste0(date_str, ".gif")),
  first_image_duration = 4,
  last_image_duration = 20,
  frame_duration = .25,
  background = bg_col
)
```

There are several components of this script that make it useful: 

* It's separated into different sections which can help to break down the process of creating a visualization into smaller, more manageable chunks. In RStudio, the Ctrl+Shift+R keyboard shortcut can be used to add a new section.

* It defines variables and code snippets that are used repeatedly in different visualizations. For example, defining variables for the colors and fonts, or using the theme elements from {ggtext} to style the title and subtitle text.

* There are also some elements of the script that are similar for each plot, but not exactly the same. For example, reading in the data using the {tidytuesdayR} package or saving the gif created by {camcorder}. Here, the code is changing based on the date associated with the \#TidyTuesday data. Instead of manually editing the date in the script in each location, a `date_str` variable is defined at the top of the script - meaning you only need to set the date once. 

You can also create template files for other aspects of your data visualization workflow. For example, creating a `README.md` file for each visualization.

## Writing your own helper functions

As you've already seen in @sec-chap6, creating functions for code you reuse frequently can save time and space. In @sec-chap6, we created the function `social_caption()` for adding a plot caption that contained Font Awesome icons. This function has then been used in every subsequent chapter (and therefore also the template file described in the previous section). What other helper functions might be useful? \index{social\_caption} 

* To use the Font Awesome icons, you need to load the Font Awesome font files. We did this using `sysfonts::font_add()` and specifying a path to the font file. You might also want to load other fonts that aren't normally available on your system or through Google Fonts. You could write a function that loads (multiple) font files that you use often. You could go one step further and place the fonts and your font loading function into an R package. 

* For the template file discussed in the previous section, the date was defined as a variable at the top of the script. Instead, you could create a function that takes the date as in argument. The function could then create your .R script, insert the date where it needs to go, and save the file to the desired location. 

* If you're creating plots for a corporate reports, creating your own {ggplot2} theme and color palette functions can save time implementing the same styling and colors for every visualization. It can also make it easier for other people you work with to use the same styling.

\index{sysfonts!font\_add} 

You can create helper functions for anything that you do often. If you don't use Font Awesome icons in your captions, you don't need to create the `social_caption()` function. But if, for example, you always save your images in a specific size with a specific background color, create a function that does that. You'll be amazed at how much time you can save.

\index{social\_caption} 