---
filters:
  - line-highlight
execute: 
  freeze: auto
---

# Programming Languages: dumbbell charts with {ggplot2} {#sec-programming}

In this chapter we'll learn how to combine points and lines to create dumbbell charts, create data-driven captions using the {glue} package, and understand how to style charts using themes, fonts, and colors in {ggplot2}.

## Data

In this chapter, we're going to explore the Programming Languages Database (PLDB) [@pldb_data]. This database is an encyclopaedia of programming languages, containing information on rankings, when it was created, what type of language it is, and how many GitHub repositories use the language - to name just a few variables. Programming language creators can use the database to help design and improve programming languages, whilst programming language users can use the database to help make decisions about which languages to use or learn. 

The PLDB is *published to the public domain* and can be found online at [pldb.io](https://pldb.io/), where you can make queries and view the data. You can also download the data in CSV or JSON format. The PLDB data was used as a \#TidyTuesday dataset in March 2023, meaning we can also easily load the data into R using the {tidytuesdayR} R package [@tidytuesdayR]. 

The {tidytuesdayR} R package has several functions for helping to get data and information about \#TidyTusday data into R. One of the most commonly used functions is the `tt_load()` function, which loads the data from a specific week (specified by the data) into your R session. For a given week, there may be multiple datasets, and a specific one can be accessed using the `$` notation: \index{tidytuesdayR!tt\_load} \index{TidyTuesday}

```{r}
#| label: langauges-load-data-show
#| eval: false
#| echo: true
tuesdata <- tidytuesdayR::tt_load("2023-03-21")
languages <- tuesdata$languages
```

```{r}
#| label: langauges-load-data-hide
#| output: false
#| echo: false
#| eval: true
languages <- readr::read_csv("data/languages.csv")
```

You can alternatively read the data in via {tidytuesdayR} using the year and week. For example `languages <- tidytuesdayR::tt_load(2023, week = 12)`, but personally I find remember the date much easier! You can also read the data in directly from the CSV file on GitHub using `read.csv()` or `read_csv()` from {readr}. 

What does the data look like? We can inspect the first six rows of the data using `head()`:

```{r}
#| label: langauges-data-head
#| out-width: 50%
head(languages)
```

You can also use `View()` to open a new tab in RStudio to inspect the data in something that resembles a non-editable spreadsheet file - if you prefer a more human-readable format. Inspecting the data in this very basic way (simply looking at it with our eyes first) helps to ensure that the data has been read in correctly. This dataset has `r nrow(languages)` rows and `r ncol(languages)` columns - giving us many options for variables to explore further. What variables do we have? The data description contained in the \#TidyTuesday GitHub repository ([github.com/rfordatascience/tidytuesday/blob/master/data/2023/2023-03-21/readme.md](https://github.com/rfordatascience/tidytuesday/blob/master/data/2023/2023-03-21/readme.md)) is often a good plaece to start. A table containing the column names and what the data in each column means, can help give you some more context for the data you are looking at - especially since columns are not always named intuitively! For the PLDB dataset, you can also look at an even more in-depth description of the variables on the dataset's website at [pldb.io/csv.html](https://pldb.io/csv.html). Here, you'll also notice that the \#TidyTuesday version of this dataset is a subset of a larger dataset which contains 356 variables - we'll stick with the smaller version for this chapter!

There are many variables with missing (`NA`) values in the PLDB - few languages have an entry in the `description` column, `github_` columns, `reference` column, or `is_open_source` column. Missing values are highly important - we don't just want to discard rows or columns with missing values as they can often tells us a lot of important information about our data. There are many methods of dealing with missing data, and which method you use will depend on what you are trying to achieve. 

for example - maybe due to github only being created in 2008 (a language that was created and died before 2008 is unlikely to have one - discarding rows with na .. means we bias our analysis to newer languages.)

Having said that, this isn't a statistics book, so for the purposes of visualisation we'll focus on columns that are mostly complete.

Often when we're working with data, there is some *outcome* that we're interested in. Depending on your field, you might instead hear this called the *response* variable or the *dependent variable*. You might have multiple outcomes of interest. For example, in the PLDB data, we might be interested in what affects the ranking and/or the number of GitHub stars for a programming language. 

something about also visualising multiple covariates against each other. what are the variables of interest here 

## Exploratory work

beyond looking at teh data, counting the rows and oclumns, and imspecting the values in different columns, a key part of exploratory work is visualising data. These initial explorations can help you to check if there are any issues with your data (e.g. misspelled Monday as Mnoday). They can also help to identify interesting relationship or patterns in the data, which can guide you to further avenues for ... and appropriate modelling techniques.

In this book, we'll primarily use base R for initial exploration and ..., and then {ggplot2} and it's associated extension packages to create our final .. in each chapter. not to say base R not good, 

There are many different types of plot, ... ne wall the time,/ But often, for those initial ..., the classic ... . Scatter plots are useful for exploring a relationship between two continuous variables; Boxplots are useful for exploring between a categorical and continuous variable; bar charts for exploring between categories; and line charts for ... how change over time. 

### Data exploration

we can#t explore every column here, so we'll start with 

The `language_rank` is the most obvious outcome that we might want to consider. Note that, in this data, the rank starts at 0 (joke about index at 1 being better). We might want to look at the `last_activity` column in relation to the rank - are programming languages with more recent activity also more popular? Let's start by making a scatter plot of last activity (on the x-axis) and language rank (on the y-axis).

```{r}
#| label: fig-languages-scatter
#| fig-cap: ""
plot(
  languages$last_activity, languages$language_rank
)
```

Straight away this highlights the role of data visualisation in exploratory analysis. This scatter plot don't look quite right - the `last_activity` data ranges from around -1000 to just over 2000, with most of the values close to the 2000 mark. If this is supposedly a date column, we need to think about whether these values are correct. 

* Are these simply incorrect entries?
* Are these missing values? It's not uncommon for missing values to be encoded as `-999` for example. This is especially true if data has been processed in some other software before it's loaded into R. Just because you have  - values can be missing for different reasons, and sometimes they are encoded in multiple ways to demonstrate this difference. 
* Are these values transformed in some way we don't expect? Dates can be encoded as integer values - often as number of dates since some origin time. The origin time used in R is often `"1970-01-01"`, so it's perfectly reasonable to have negative dates if you're dealing with data pre-1970. 

In this case, the dates are actually given as a year (rather than a `Date` object) so the negative values are unlikely to be  actually years so prob correct we could filter out,

first programming lang 1950s (need source) \index{base!subset}

```{r}
#| label: fig-languages-scatter-filter
#| fig-cap: ""
lang_df <- subset(languages, last_activity >= 1950)
plot(
  lang_df$last_activity, lang_df$language_rank
)
```

::: {#tip-languages-subset .callout-tip}

You can also subset the data using the `filter()` function from {dplyr}, either with or without the use of the pipe operator: \index{dplyr!filter}

```{r}
#| label: languages-filter
#| eval: false
#| echo: true
lang_df <- dplyr::filter(languages, last_activity >= 1950)
```

The ... If we're plotting in {ggplot2}, we'll prepare data using other {tidyverse} packages. But here, where we're plotting in base R, we'll prepare data using base R as well.

:::

Though the name of the Programming Languages Database may suggest that it focuses exclusively on programming languages, this isn't true. It also includes information on query languages, stylesheet languages, and protocols, amongst other things. Let's look at the balance between these different types of languages in the data using a bar chart created using the `barplot()` function from the {graphics} package in base R. \index{graphics!barplot}

```{r}
#| label: fig-languages-pl-barplot
#| fig-cap: ""
barplot(
  table(lang_df$type)
)
```

```{r}
#| label: fig-languages-comment-barplot
#| fig-cap: ""
barplot(
  sort(table(lang_df$line_comment_token))
)
```

### Exploratory sketches

![Initial sketch of a dumbbell chart showing the time frame that different languages are active for a specific comment character.](images/sketch-languages.png){#fig-languages-sketch fig-align="center"}

## Preparing a plot

mention dumbbell package

### Data wrangling

```{r}
#| label: langauges-data-wrangling-1
comment_df <- lang_df |>
  dplyr::filter(type == "pl") |>
  dplyr::filter(line_comment_token %in% c("//", "#", ";")) |>
  dplyr::select(
    title, appeared, line_comment_token, last_activity, language_rank
    ) |>
  tidyr::drop_na()
```

```{r}
#| label: langauges-data-wrangling-2
comment_df2 <- comment_df |> 
  dplyr::mutate(
    label = paste("Comment token:", line_comment_token)
    ) |>
  dplyr::group_by(label) |>
  dplyr::slice_head(n = 10) |>
  dplyr::mutate(
    n = factor(dplyr::row_number(), levels = 1:10)
    ) |>
  dplyr::ungroup() |>
  dplyr::select(
    label, n, title, appeared, last_activity, language_rank
    )
```

need to rename to something better

```{r}
#| label: langauges-data-wrangling-3
plot_data <- comment_df2 |> 
  tidyr::pivot_longer(
    cols = c(appeared, last_activity),
    names_to = "type",
    values_to = "year"
  )
```

### Packages and functions

### The first plot

maybe split into two or three

```{r}
#| label: fig-langauges-basic-plot1
#| warning: false
library(ggplot2)
basic_plot <- ggplot(data = plot_data) +
  geom_line(mapping = aes(x = year, y = n, group = n)) +
  geom_point(mapping = aes(x = year, y = n)) +
  facet_wrap(~label)
basic_plot
```

reorder axes

```{r}
#| label: fig-langauges-scales-plot
basic_plot +
  scale_y_discrete(limits = rev) +
  scale_x_continuous(
    breaks = c(1970, 1990, 2010, 2030),
    limits = c(1930, 2030),
    expand = c(0, 0)
  )
```

update to open ended

## Advanced styling

### Colors

Why save colors as variables?

```{r}
#| label: langauges-color-vars
bg_col <- "grey5"
main_col <- "#66FF00"
```

redo plot

```{r}
#| label: fig-langauges-basic-plot2
basic_plot <- ggplot(data = plot_data) +
  geom_line(
    mapping = aes(x = year, y = n, group = n),
    color = main_col
  ) +
  geom_point(
    mapping = aes(x = year, y = n),
    color = main_col,
    fill = bg_col,
    pch = 22
  ) +
  facet_wrap(~label) +
  # add scales back in
  scale_y_discrete(limits = rev) +
  scale_x_continuous(
    breaks = c(1970, 1990, 2010, 2030),
    limits = c(1930, 2030),
    expand = c(0, 0)
  )
basic_plot
```

### Text and fonts

{sysfonts}\index{sysfonts}
{showtext}\index{showtext}

alterntives to showtext

Text as variables

```{r}
#| label: langauges-text-vars
title <- "Programming Languages"
subtitle <- "Of the 4,303 programming languages listed in the Programming Language DataBase, 205 use //, 101 use #, and 64 use ; to define which lines are comments. 3,831 languages do not have a comment token listed."
caption <- "Data: Programming Language DataBase | Graphic: N. Rennie"
```

subtitle ... can wegenerate from text - use glue 

add to plot

```{r}
#| label: fig-langauges-text_plot
text_plot <- basic_plot +
  labs(
    title = title,
    subtitle = subtitle,
    caption = caption
  )
text_plot
```

runs off the edge - we'll deal with that later

Choosing a font

showtext
google fonts

```{r}
#| label: langauges-showtext
sysfonts::font_add_google("VT323", "vt")
sysfonts::font_add_google("Share Tech Mono", "share")
showtext::showtext_auto()
showtext::showtext_opts(dpi = 300)
```

font as variables


```{r}
#| label: langauges-font-vars
body_font <- "share"
title_font <- "vt"
```


basic theming

```{r}
#| label: langauges-minimal-theme
theme_plot1 <- text_plot +
  theme_minimal(
    base_size = 8,
    base_family = body_font
  )
```

### Adjusting themes

better theme

```{r}
#| label: fig-langauges-style1
theme_plot1 +
  theme(
    plot.background = element_rect(
      fill = bg_col,
      color = bg_col
    ),
    panel.background = element_rect(
      fill = bg_col,
      color = alpha(main_col, 0.5),
      linewidth = 0.4
    ),
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_line(
      color = alpha(main_col, 0.5),
      linewidth = 0.2
    ),
    panel.grid.major.y = element_blank(),
    strip.text = element_text(
      color = main_col
    ),
    axis.text.y = element_blank(),
    axis.text.x = element_text(
      color = main_col,
      vjust = 2
    ),
    plot.title = element_text(
      color = main_col,
      family = title_font
    ),
    plot.subtitle = element_text(
      color = main_col,
      margin = margin(b = 5)
    ),
    plot.caption = element_text(
      color = main_col,
      margin = margin(b = 5),
      hjust = 0
    ),
    axis.ticks = element_blank(),
    plot.margin = margin(10, 15, 5, 0)
  )
```

make title bigger
stop subtitle running off - a few options, line breaks. str_wrap, ggtext
ggtext

```{r}
#| label: fig-langauges-style2
theme_plot2 <- theme_plot1 +
  theme(
    plot.background = element_rect(
      fill = bg_col,
      color = bg_col
    ),
    panel.background = element_rect(
      fill = bg_col,
      color = alpha(main_col, 0.5),
      linewidth = 0.4
    ),
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_line(
      color = alpha(main_col, 0.5),
      linewidth = 0.2
    ),
    panel.grid.major.y = element_blank(),
    strip.text = element_text(
      color = main_col
    ),
    axis.text.y = element_blank(),
    axis.text.x = element_text(
      color = main_col,
      vjust = 2
    ),
    plot.title = element_text(
      color = main_col,
      family = title_font,
      size = rel(2)
    ),
    plot.subtitle = ggtext::element_textbox_simple(
      color = main_col,
      margin = margin(b = 5),
      lineheight = 0.5
    ),
    plot.caption = element_text(
      color = main_col,
      margin = margin(b = 5),
      hjust = 0
    ),
    axis.ticks = element_blank(),
    plot.margin = margin(10, 15, 5, 0)
  )
theme_plot2
```

Add labels

```{r}
#| label: fig-langauges-add-labels
theme_plot2 +
  geom_text(
    mapping = aes(x = 1932, y = n, label = title),
    family = body_font,
    vjust = 0.5,
    hjust = 0,
    size = 3,
    color = main_col
  )
```


make better labels

```{r}
#| label: langauges-better-labels
plot_data <- plot_data |>
  dplyr::mutate(
    rank_label = glue::glue("{title}\nRank: {language_rank}")
    )
```

plot

```{r}
#| label: fig-langauges-add-better-labels
theme_plot2 +
  geom_text(
    data = plot_data,
    mapping = aes(x = 1932, y = n, label = rank_label),
    family = body_font,
    vjust = 0.5,
    lineheight = 0.7,
    hjust = 0,
    size = 2.5,
    color = main_col
  )
```


Saving an image

comments on dpi

```{r}
#| label: langauges-save
#| eval: false
#| echo: true
ggsave()
```

## Reflection

open ended

labels html in later chapters

::: {.content-visible when-format="html"}

## The making of...

Each plot created during the process of developing the original version of this visualisation was captured using {camcorder}, and is shown in the gif below. If you'd like to learn more about how {camcorder} can be used in the data visualisation process, see @sec-camcorder.

![](images/languages.gif){fig-align="center"}

:::
