---
filters:
  - line-highlight
execute: 
  freeze: auto
fig-width: 5
fig-asp: 0.92
---

```{r}
#| echo: false
#| eval: true
#| file: R/options.R
```

```{r}
#| echo: false
#| eval: true
#| file: R/load_font_awesome.R
```

```{r}
#| echo: false
#| eval: true
#| file: R/social_caption.R
```

# Time Zones: Spatial data and mapping with {sf} {#sec-time-zones}

In this chapter we'll learn how to obtain map data using {rnaturalearth}, manipulate spatial data using {sf} and plot it with {ggplot2}, and add a custom bar chart legend to a map of the world. \index{sf} \index{ggplot2} \index{rnaturalearth}

## Data

The [IANA (Interet Assigned Numbers Authority) tz database](https://data.iana.org/time-zones/tz-link.html) contains data on the history of local time for different locations around the world [@zones_data]. The website states that *"each main entry in the database represents a timezone for a set of civil-time clocks that have all agreed since 1970."* Many websites use the data in the IANA tz database to operate.

The time zones data was used as a [\#TidyTuesday dataset in March 2023](https://github.com/rfordatascience/tidytuesday/blob/master/data/2023/2023-03-28/readme.md), where the data wrangling code was adapted from code by [Davis Vaughan](https://gist.github.com/DavisVaughan). There are actually four data sets included but we'll focus on the `timezones` data for now. We can load the data in using the `tt_load()` function from the {tidytuesdayR} package [@tidytuesdayR]: \index{tidytuesdayR!tt\_load}

```{r}
#| label: load-timezones-data-show
#| eval: false
#| echo: true
tuesdata <- tidytuesdayR::tt_load("2023-03-28")
timezones <- tuesdata$timezones
```

```{r}
#| label: load-timezones-data-hide
#| output: false
#| echo: false
#| eval: true
timezones <- readr::read_csv("data/timezones.csv")
```

The data contains information for `r ncol(timezones)` different variables on `r nrow(timezones)` time zones. The `zone` column contains the time zone name; the `latitude` and `longitude` columns contain coordinates for the time zones *principal location* e.g. biggest city; and the `comments` column contains comments from the original time zone definition file.

## Exploratory work

Let's start by looking at what the `timezones` data looks like!

### Data exploration

When we inspect the first few rows of the data:

```{r}
#| label: timezones-head
head(timezones)
```

the first thing that jumps out is the `comments` column which appears to have a lot of missing data. Let's plot it to confirm, making use of the `is.na()` function to plot only the counts of missing and non-missing data:

```{r}
#| label: timezones-barplot-na
barplot(
  table(is.na(timezones$comments)),
  cex.axis = 0.5,
  cex.names = 0.5
)
```

almost 40% of the time zones have no comments associated with them. Inspecting the data further tells us that these comments typically offer clarification or an alternative for the timezone name. Although we could explore how the presence of these comments varies across the globe, we'll use `select()` from {dplyr} to drop the `comments` column for now since it's not the most interesting thing to plot in the data.

The first column, `zone`, contains information on the timezone name - it's typically in the form of `"Continent/City"`. To explore the spread of time zones across continents, we need to split this variable into two (or extract just the continent name from the timezone name). We can use `separate_wider_delim()` from {tidyr} to create two new columns from the `zone` column, splitting on the `/` character. Some of the timezone names have two `/` in their name e.g. `"America/North_Dakota/New_Salem"` meaning there are *too many* pieces for two columns. We can tell `separate_wider_delim()` to merge the last pieces since it still uniquely specifies the location. \index{dplyr!select} \index{tidyr!separate\_wider\_delim}

```{r}
#| label: timezones-tidy
timezones_data <- timezones |>
  dplyr::select(-comments) |> 
  tidyr::separate_wider_delim(
    cols = zone,
    delim = "/",
    names = c("continent", "place"),
    too_many = "merge"
  )
```

Now, we can explore how many time zones there are per continent:

```{r}
#| label: timezones-barplot-loc
barplot(
  table(timezones_data$continent),
  cex.axis = 0.5,
  cex.names = 0.5
)
```

We can see that, actually, the first part of the time zone names don't quite map to continents since there are nine values - but they do map onto large geographic regions. 

Of course, when we have coordinate data, the most obvious thing to do is plot those coordinates on a map...

### Exploratory sketches



![Initial sketch of points on a world map with text in the lower left corner, and a bar chart as a legend in the bottom right.](images/sketch-time-zones.png){#fig-time-zones-sketch fig-align="center"}

## Preparing a plot

To make our plot, we need to get some background map data and understand how to work with multiple spatial data files at once.

### Maps with {rnaturalearth}

Before we start plotting points on a map, we need a map of the world that we can use as a background to show the underlying countries. 
In @sec-doctors, we used `map_data` from {ggplot2}. Here, let's look at an alternative using the {rnaturalearth} package [@rnaturalearth]. 

The {rnaturalearth} package allows you to interact with [Natural Earth](https://www.naturalearthdata.com/) map data. You can download polygons for different geographic regions using the `ne_countries()` function. The default is to download data for all countries: \index{rnaturalearth!ne\_countries}

```{r}
#| label: timezones-map-data
world <- rnaturalearth::ne_countries()
```

::: {#tip-timezones-rnatearth .callout-tip}

If you wanted only the polygon(s) for a specific country or region, you can specify the `country` argument:

```{r}
#| label: timezones-ne-country
#| eval: false
uk <- rnaturalearth::ne_countries(country = "united kingdom")
```

For specified countries, the `ne_states()` function provides administrative level 1 polygons e.g. major within-country regions such as states.

:::

The default output from the `ne_countries()` function is an `sf` object - where `sf` stands for *Simple Features*. Simple Features is a standardised model for representing geometric objects such as points, lines, and polygons in spatial databases and geographic information systems (GIS). The {sf} package [@sf] implements simple features in R, allowing simple features to be represented as a `data.frame` (or `tibble`). \index{sf} 

Since `sf` objects in R can be thought of as fancy data.frames, this means they can be plotted using {ggplot2}. In fact, {ggplot2} has built-in capabilities for plotting `sf` objects - through the `geom_sf()` function. That means that we can build maps from `sf` objects, in the same we we build other types of charts: by starting with the `ggplot()` function, and then layering on the `geom_sf()` geometry: \index{ggplot2!ggplot} \index{ggplot2!geom\_sf}

```{r}
#| label: fig-timezones-bg-map
#| fig-cap: "Map of the world showing country outlines, with the default gray background."
library(ggplot2)
bg_map <- ggplot() +
  geom_sf(data = world)
bg_map
```

You'll notice that there's one key difference - there's no aesthetic mapping using the `aes()` function. Since the spatial coordinates are embedded within the `sf` object, there's no need to explicitly map the `x` and `y` variables. The `geom_sf()` function can directly extract and use the embedded coordinates for plotting.

### Spatial objects with {sf}

Though you can combine `geom_sf()` with other geometries, such as `geom_point()`, it's often easier to convert the other geometries to `sf` objects first. The main reason for this is to ensure the *coordinate reference system (CRS)* is the same for both geometries. Coordinate reference systems define how the three dimensional nature of the earth is mapped onto a two-dimensional projected map. There are many different coordinate reference systems, each commonly used for different areas of the world. If you're combining multiple spatial objects, they may have different coordinate reference systems. For example, using the British National Grid (BNG) CRS, London has the following coordinates: `X = 492983` and `Y = 188837`. Under the World Geodetic System 1984 (WGS84) CRS, London has the following coordinates: `Longitude (X) = 1.200235W` and `Latitude (Y) = 53.870659N`. You can imagine how these two coordinates cannot be plotted on the same map without transforming them first. 

In R, you use the {sf} to set or transform between different coordinate reference systems. The easiest way is by using EPSG codes - numerical identifiers assigned to specific coordinate reference systems. The WGS84 uses EPSG code `4326`. This is the coordinate reference system used in the `world` data that we're using for the background map. You can check using the `st_crs()` function from {sf} which retrieves the CRS from an object: \index{sf!st\_crs}

```{r}
#| label: crs-sf
sf::st_crs(world)
```

To make sure the CRS of the `timezones` data matches the CRS of the `world` data, we can set the CRS of the `timezones` data as `4326`. At the moment, the `timezones` data is not a spatial object - it's just a simple `data.frame` that contains two columns with latitude and longitude information. First, we need to convert it into an `sf` object using the `st_as_sf()` function from {sf}, also specifying the column names that relate to the coordinates data. \index{sf!st\_as\_sf} 

The latitude and longitude coordinates given in the `timezones` data are given in the `EPSG:4326` CRS, so we don't need to convert the CRS - just set it. We know it's in `EPSG:4326` because this information is given to us with the data. We can use the `st_set_crs()` to set the coordinate reference system to `EPSG:4326` \index{sf!st\_set\_crs}.

```{r}
#| label: timezones-sf
timezones_sf <- timezones_data |>
  sf::st_as_sf(coords = c("longitude", "latitude")) |>
  sf::st_set_crs(4326)
```

::: {#tip-timezones-crs .callout-tip}

If you don't know which CRS your coordinates are in, the best thing to do is go back to the source of the data to see if you can find that information. Otherwise, you may wish to try the `guess_crs()` function from {crsuggest} [@crsuggest] which will *guess* potential coordinate reference systems for data that are lacking a defined CRS. \index{crsuggest!guess\_crs}

:::

### The first plot

\index{ggplot2!aes} \index{ggplot2!geom\_sf}

```{r}
#| label: fig-timezones-basic-map
#| fig-cap: "Points representing different time zone locations on a world map, with points colored by continent and a legend indicating color mapping on the right of the map."
basic_map <- bg_map +
  geom_sf(
    data = timezones_sf,
    mapping = aes(color = continent)
  )
basic_map
```

## Creating a custom legend

Before we create a legend map, we need to define which colors will be used in the legend (and the rest of the plot).

### Colors

As we've done in previous chapters, we start by defining a text color, highlight color, and background color as variables.

```{r}
#| label: timezones-colors
text_col <- "#2F4F4F"
highlight_col <- "#508080"
bg_col <- "#F0F5F5"
```

Then we define a named vector of colors, mapping the names of regions to different hex codes. It can be difficult to find a qualitative color palette with enough colors (one for each of the nine regions) that remains colorblind safe. Paul Tol ... ... [website](https://personal.sron.nl/~pault/) [@Tol2021]

Here, we use the *muted qualitative color scheme* palette from @Tol2021:

```{r}
#| label: timezones-col-palette
col_palette <- c(
  "Africa" = "#CC6677",
  "America" = "#332288",
  "Antarctica" = "#DDCC77",
  "Asia" = "#117733",
  "Atlantic" = "#88CCEE",
  "Australia" = "#882255",
  "Europe" = "#44AA99",
  "Indian" = "#999933",
  "Pacific" = "#AA4499"
)
```

### Fonts

\index{sysfonts!font\_add\_google} \index{showtext!showtext\_auto} \index{showtext!showtext\_opts}

```{r}
#| label: timezones-fonts
sysfonts::font_add_google("Commissioner")
sysfonts::font_add_google("Fraunces")
showtext::showtext_auto()
showtext::showtext_opts(dpi = 300)
body_font <- "Commissioner"
title_font <- "Fraunces"
```

### Bar chart legend

The ... the `geometry` column in ... is often described as *sticky*. 

\index{sf!st\_drop\_geometry} \index{dplyr!count}

```{r}
#| label: timezones-bar-data
bar_data <- timezones_sf |>
  dplyr::count(continent) |>
  sf::st_drop_geometry()
```

\index{ggplot2!ggplot} \index{ggplot2!aes} \index{ggplot2!geom\_col} \index{ggplot2!scale\_fill\_manual}

```{r}
#| label: fig-timezones-bar-plot-1
#| fig-cap: "Bar chart showing the number of time zone locations in each continent, with different colors for each continent."
#| fig-asp: 0.7
bar_plot <-
  ggplot(
    data = bar_data,
    mapping = aes(
      x = continent, y = n,
      fill = continent, label = continent
    )
  ) +
  geom_col() +
  scale_fill_manual(
    values = col_palette
  )
bar_plot
```

\index{ggtext!geom\_textbox} \index{dplyr!case\_when} \index{base!I}  \index{ggplot2!theme} \index{ggplot2!theme\_void}

```{r}
#| label: fig-timezones-bar-plot-2
#| fig-cap: "A minimalist bar chart showing the number of time zone locations in each continent, with labels on each bar naming the continent."
#| fig-asp: 0.7
legend_plot <- bar_plot +
  ggtext::geom_textbox(
    mapping = aes(
      hjust = dplyr::case_when(
        n > 45 ~ 1,
        TRUE ~ 0
      ),
      halign = dplyr::case_when(
        n > 45 ~ 1,
        TRUE ~ 0
      ),
      color = dplyr::case_when(
        n > 45 ~ I(bg_col),
        TRUE ~ I(text_col)
      )
    ),
    family = body_font,
    size = 3,
    fill = NA,
    box.color = NA,
    orientation = "left-rotated"
  ) +
  theme_void() +
  theme(
    legend.position = "none"
  )
legend_plot
```

## Advanced styling

### Applying colors

\index{ggplot2!ggplot} \index{ggplot2!alpha} \index{ggplot2!geom\_sf} \index{ggplot2!aes}

```{r}
#| label: fig-timezones-basic-map-2
#| fig-cap: "test"
basic_map <- ggplot() +
  geom_sf(
    data = world,
    color = text_col,
    fill = alpha(highlight_col, 0.3)
  ) +
  geom_sf(
    data = timezones_sf,
    mapping = aes(color = continent),
    size = 0.4,
  ) +
  geom_sf(
    data = timezones_sf,
    mapping = aes(color = continent),
    size = 1.6,
    pch = 21,
    fill = "transparent"
  )
basic_map
```

We also apply the same colors (remembering to use `scale_color_manual()` rather than `scale_fill_manual()` as ... )

\index{ggplot2!scale\_color\_manual}

```{r}
#| label: timezones-style-map-1
col_map <- basic_map +
  scale_color_manual(
    values = col_palette
  )
```

### Text 

\index{social\_caption}
 
```{r}
#| label: timezones-text-social
social <- social_caption(
  bg_color = bg_col,
  icon_color = highlight_col,
  font_color = text_col,
  font_family = body_font
)
```

\index{glue!glue}
 
```{r}
#| label: timezones-text
cap <- glue::glue("Time zones tend to follow the boundaries between countries and their subdivisions instead of strictly following longitude. For every one-hour time, a point on the earth moves through 15 degrees of longitude. Each point relates to one of 337 time zones listed in the IANA time zone database. The colors show which time zones are in
<span style='color:{col_palette[\"Africa\"]};'>Africa </span>,
<span style='color:{col_palette[\"America\"]};'>America </span>,
<span style='color:{col_palette[\"Antarctica\"]};'>Antarctica </span>,
<span style='color:{col_palette[\"Asia\"]};'>Asia </span>,
<span style='color:{col_palette[\"Atlantic\"]};'>Atlantic </span>,
<span style='color:{col_palette[\"Australia\"]};'>Australia </span>,
<span style='color:{col_palette[\"Europe\"]};'>Europe </span>,
<span style='color:{col_palette[\"Indian\"]};'>Indian </span>, and
<span style='color:{col_palette[\"Pacific\"]};'>Pacific </span> zones.<br>**Data**: IANA tz database<br>")
title <- glue::glue("<span style='font-size:12pt; font-family:{title_font}; color:{text_col};'>Time Zones of the World</span><br>")
caption <- glue::glue("{title}{cap}")
```

### Adjusting themes

add lines

\index{ggplot2!geom\_segment} \index{ggplot2!aes} \index{ggplot2!alpha} \index{ggplot2!scale\_x\_continuous} \index{ggplot2!coord\_sf}

```{r}
#| label: fig-timezones-style-map-2
#| fig-cap: "test"
line_map <- col_map +
  geom_segment(
    data = data.frame(x = seq(-180, 180, by = 15)),
    mapping = aes(x = x, y = -170, xend = x, yend = 100),
    linewidth = 0.2,
    color = alpha(highlight_col, 0.2)
  ) +
  scale_x_continuous(
    breaks = seq(-180, 180, by = 15),
    limits = c(-190, 190)
  ) +
  coord_sf(expand = FALSE)
line_map
```

\index{ggtext!geom\_textbox} \index{ggplot2!aes} \index{ggplot2!labs}

```{r}
#| label: timezones-style-map-3
text_map <- line_map +
  ggtext::geom_textbox(
    data = data.frame(x = 0, y = 93, label = social),
    mapping = aes(x = x, y = y, label = label),
    family = body_font,
    size = 2.5,
    fill = NA,
    halign = 0.5,
    hjust = 0.5,
    valign = 0,
    box.color = NA
  ) +
  labs(tag = caption)
```

theme void \index{ggplot2!theme\_void}

theme \index{ggplot2!theme} \index{ggtext!element\_textbox\_simple} \index{ggplot2!element\_rect}

```{r}
#| label: fig-timezones-style-map-4
#| fig-cap: "test"
styled_map <- text_map +
  theme_void(base_size = 6, base_family = body_font) +
  theme(
    legend.position = "none",
    plot.margin = margin(0, 0, 0, 0),
    plot.background = element_rect(
      fill = bg_col,
      color = bg_col
    ),
    # add and position text
    plot.tag.position = c(-0.01, 0.12),
    plot.tag = ggtext::element_textbox_simple(
      color = text_col,
      hjust = 0,
      maxwidth = grid::unit(200, "pt"),
      margin = margin(
        l = 15, t = 5, b = 10
      )
    )
  )
styled_map
```

### Join with {patchwork}

Finally, we need to join the legend bar chart to our main plot. For this, we'll use the {patchwork} package [@patchwork] - just as we did in @sec-lemurs to assembly multiple plots into a grid. 

In this visualisation, rather than arranging plots side by side, we instead want to position one plot (bar chart) on top of another (main map). We start with our `styled_map` and add the `legend_plot` on top using the `inset_element()` function. The positions ... \index{patchwork!inset\_element}

theme \index{ggplot2!theme}

```{r}
#| label: fig-timezones-final-plot
#| fig-cap: "test"
library(patchwork)
styled_map + inset_element(legend_plot, 0.55, 0, 1, 0.3) &
  theme(plot.margin = margin(0, 0, 0, 0))
```

Our map is finished!

## Reflection

* vert lines don't need to go through text as well

* bars could do with some exaplantion

::: {.content-visible when-format="html"}

Each plot created during the process of developing the original version of this visualisation was captured using {camcorder}, and is shown in the gif below. If you'd like to learn more about how {camcorder} can be used in the data visualisation process, see @sec-camcorder.

![](images/time-zones.gif){fig-align="center"}

:::
