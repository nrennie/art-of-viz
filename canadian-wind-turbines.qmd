---
filters:
  - line-highlight
execute: 
  freeze: auto
fig-width: 5
fig-asp: 0.75
---

```{r}
#| echo: false
#| eval: true
#| file: R/options.R
```

# Canadian Wind Turbines: waffle plots, pictograms, and icons {#sec-turbines}

In this chapter, we'll learn how 

## Data

[https://open.canada.ca/data/en/dataset/79fdad93-9025-49ad-ba16-c26d718cc070](https://open.canada.ca/data/en/dataset/79fdad93-9025-49ad-ba16-c26d718cc070)

[@readxl] [@openxlsx]

\index{readxl!read\_xlsx}

\index{openxlsx!read.xlsx} \index{utils!write.csv}

```{r}
#| label: turbines-download
#| eval: false
#| echo: true
wind_turbines <- openxlsx::read.xlsx("https://ftp.cartes.canada.ca/pub/nrcan_rncan/Wind-energy_Energie-eolienne/wind_turbines_database/Wind_Turbine_Database_FGP.xlsx", sheet = 1)
write.csv(wind_turbines, "data/wind_turbines.csv", row.names = FALSE)
```

\index{readr!read\_csv}

```{r}
#| label: turbines-data
#| output: false
wind_turbines <- readr::read_csv("data/wind_turbines.csv")
```


## Exploratory work

### Data exploration

### Exploratory sketches

## Preparing a plot

### Data wrangling


\index{dplyr!if\_else} \index{stringr!str\_detect} \index{stringr!str\_match}

```{r}
#| label: turbines-extract
extract_after_last_slash <- function(texts) {
  has_slash <- stringr::str_detect(texts, "/")
  extracted <- stringr::str_match(texts, ".*/(.*)$")[, 2]
  output <- dplyr::if_else(has_slash, extracted, texts)
  return(output)
}
```

\index{dplyr!select} \index{base!as.numeric}

```{r}
#| label: turbines-year-data
turbines_year <- wind_turbines |>
  dplyr::select(`Province/Territory`, Commissioning.date) |>
  dplyr::mutate(
    Year = extract_after_last_slash(Commissioning.date),
    Year = as.numeric(Year)
  )
```

\index{dplyr!filter} \index{dplyr!mutate} \index{dplyr!case\_when} \index{base!factor}

```{r}
#| label: turbines-data-wrangling-1
turbines_year_group <- turbines_year |>
  dplyr::filter(Year >= 2001 & Year <= 2020) |>
  dplyr::mutate(
    Year_Group = dplyr::case_when(
      Year %in% seq(2001, 2005) ~ "2001 - 2005",
      Year %in% seq(2006, 2010) ~ "2006 - 2010",
      Year %in% seq(2011, 2015) ~ "2011 - 2015",
      Year %in% seq(2016, 2020) ~ "2016 - 2020"
    )
  ) |>
  dplyr::mutate(
    Year_Group = factor(Year_Group, levels = c(
      "2001 - 2005", "2006 - 2010", "2011 - 2015", "2016 - 2020"
    ))
  )
```

\index{dplyr!rename} \index{dplyr!mutate} \index{dplyr!case\_when} \index{dplyr!count} \index{dplyr!filter}
  
```{r}
#| label: turbines-data-wrangling-2
plot_data <- turbines_year_group |>
  dplyr::rename(Area = `Province/Territory`) |>
  dplyr::mutate(
    Area = dplyr::case_when(
      Area %in% c(
        "Northwest Territories",
        "Newfoundland and Labrador",
        "Prince Edward Island",
        "New Brunswick",
        "Manitoba",
        "Saskatchewan"
      ) ~ "other",
      TRUE ~ Area
    )
  ) |>
  dplyr::count(Area, Year_Group) |>
  dplyr::mutate(n = round(n / 20)) |>
  dplyr::filter(n != 0)
```

\index{dplyr!summarise} \index{dplyr!arrange} \index{dplyr!filter} \index{dplyr!pull} \index{base!factor}

```{r}
#| label: turbines-fct-levels
area_levels <- c(plot_data |>
  dplyr::summarise(n = sum(n), .by = Area) |>
  dplyr::arrange(-n) |>
  dplyr::filter(Area != "other") |>
  dplyr::pull(Area), "other")
plot_data$Area <- factor(plot_data$Area, levels = area_levels)
```

### Packages and functions

font awesome ref

add instructions about installing system through waffle, where to download

\index{sysfonts!font\_add} \index{showtext!showtext\_auto} \index{showtext!showtext\_opts}

```{r}
#| label: turbines-font-awesome
sysfonts::font_add(
  family = "Font Awesome 6",
  regular = "fonts/Font-Awesome-6-Free-Solid-900.otf"
)
showtext::showtext_auto()
showtext::showtext_opts(dpi = 300)
```


### The first plot

[@waffle]

\index{ggplot2!ggplot} \index{ggplot2!aes} \index{ggplot2!facet\_wrap}
\index{waffle!geom\_pictogram}

```{r}
#| label: fig-turbines-base-plot
#| fig-cap: "Plot"
library(ggplot2)
base_plot <- ggplot(data = plot_data) +
  waffle::geom_pictogram(
    mapping = aes(
      label = Area,
      colour = Area,
      values = n
    ),
    flip = TRUE,
    n_rows = 10,
    size = 3,
    family = "Font Awesome 6"
  ) +
  facet_wrap(~Year_Group, nrow = 1, strip.position = "bottom")
base_plot
```

turbine icons not free

\index{waffle!scale\_label\_pictogram}

```{r}
#| label: fig-turbines-icons-plot
#| fig-cap: "Plot"
icons_plot <- base_plot +
  waffle::scale_label_pictogram(
    name = NULL,
    values = c("fan", "fan", "fan", "fan", "fan", "fan"),
    guide = "none"
  )
icons_plot
```

(alternatively, you can later set `theme(legend.position = "none")` as we did )

## Advanced styling

### Colors

```{r}
#| label: turbines-cols
bg_col <- "#fafafa"
text_col <- "black"
```

Let's also define a color palette that we'll use for the color of the icons. We're looking for 6 different colors - one for area. The {rcartocolor} [@rcartocolor] package provides access to the [CARTOColors](https://carto.com/carto-colors/) color palettes for maps designed by [CARTO](https://carto.com/) [@cartocolors]. Although these palettes were primarily designed for coloring maps, the color palettes are also very effective for other types of graphics. 

In the {rcartocolor} package, categorical palettes are referred to as *qualitative* palettes. We can see all available qualitative palettes with a sufficient number of colors using `display_carto_all()`: \index{rcartocolor!display\_carto\_all}

```{r}
#| label: fig-turbines-rcarto
#| fig-cap: "All qualitative color palettes with at least 6 colors in the {rcartocolor} package."
#| fig-asp: 0.8
rcartocolor::display_carto_all(
  n = 6, type = "qualitative"
)
```

Although the {rcartocolor} package has the `scale_fill_carto_d()` which we could use directly in our plots, we'll still save the color palette as a vector of hex codes to allow us to re-use the colors more easily. As you can see in @fig-turbines-rcarto, in the qualitative palettes in the {rcartocolor} package, the last color is often a grey color. That's a great choice for representing missing data, but when we want different colors for categories it doesn't work as well. The trick is to ask for one more color than we need, and then throw away the last element in the color palette. We have 6 categories in our plot, so we ask for 7 colors using the `carto_pal()` function and then extract only the first 6. We'll use the `"Vivid"` palette here. \index{rcartocolor!carto\_pal}

We also make the `col_palette` vector a named vector by using the `names()` function, and using `area_levels` as the names. Although this isn't necessary for adding the colors to the plot, it will make it easier to extract the colors and ensure each color is mapped to the correct category label.

```{r}
#| label: turbines-col-palette
col_palette <- rcartocolor::carto_pal(
  n = length(unique(plot_data$Area)) + 1,
  name = "Vivid"
)[1:length(unique(plot_data$Area))]
names(col_palette) <- area_levels
```

We can then pass this `col_palette` vector into `scale_color_manual()` to apply the colors to our plot. Since we'll be using colored text instead of a traditional legend, we set `guide = "none"` to remove the legend again. \index{ggplot2!scale\_color\_manual}

```{r}
#| label: turbines-col-plot
col_plot <- icons_plot +
  scale_color_manual(
    values = col_palette,
    guide = "none"
  )
```

### Adding styled text

We've already seen in @sec-programming and @sec-museums how to format the title or subtitle text to be bold using the `face = "bold"` argument inside `theme()` elements. But what if we want to make only *part* of the text bold? We can use the {marquee} package [@marquee] to add styling to text within in a string. The {marquee} package allows you to use Markdown syntax in text when you're making graphics in R, including in plots built with {ggplot2} or other graphics built on {grid}. \index{marquee}

In Markdown, to make text bold, you enclose it inside two pairs of asterisks e.g. `**bold text**`. For example, if we wanted to put the entire title in bold font, we could write the title inside `**`. In the caption, we might want to embolden the words `Data` and `Graphic` to highlight that there are two different fields of information:

```{r}
#| label: turbines-text-1
title <- "**Canadian wind turbines are mostly found in Ontario**"
cap <- "**Data**: Natural Resources Canada | **Graphic**: N. Rennie"
```

This type of formatting for the plot caption is something that we might like to re-use across multiple plots. And when we want to re-use code, it's almost always useful to make it into a function. Let's define a function called `source_caption()` which has three arguments:

* `source`: a character string for the source of the data
* `graphic`: a character string for the attribution of the visualization
* `sep`: a character string for what should separate the two pieces of text, which has `" | "` as a default.

We then use `glue()` from {glue} to stick these three arguments together, and include the bold formatting using `**`. 

```{r}
#| echo: true
#| eval: true
#| file: R/source_caption.R
```

We can construct the caption using our new `source_caption()` function:

```{r}
#| label: turbines-text-2
cap <- source_caption(
  source = "Natural Resources Canada",
  graphic = "N. Rennie"
)
cap
```

You can see that it's identical to the one we manually created earlier. We'll also re-use the `source_caption()` function in later chapters.

Let's move onto the subtitle. In this visualization, the subtitle will also be doubling as a legend as we'll use colored text to denote the different categories. In {marquee}, text can be colored by wrapping the text in curly brackets, where the first word is pre-fixed by a period and identifies the color of the text i.e. `{.color text to color}`. For example, `{.red This is red text.}`. 

We want to add the colors and the text to be colored in a programmatic way. We'll use square brackets to subset the values and names stored in the `col_palette` vector. Here, `col_palette[[1]]` extracts the hex code for the color of the first category, and `names(col_palette)[[1]]` extracts the name of the first category.

Normally, when we want to write character strings and insert variables into the string, we'd use `glue()` to combine them. However, the `{}` that we normally use for variables in `glue()` will get mixed up with the `{}` we'll use for text formatting with {marquee}. There are a couple of different ways we can get around this problem. One way is changing the delimiters used in `glue()`. For example, by setting `.open = "["` and `.close = "]"` inside the `glue()` function. Alternatively, we can use `marquee_glue()` from the {marquee} package - an equivalent version of `glue()` that was built to deal with this problem.

```{r}
#| label: turbines-text-3
st <- marquee::marquee_glue(
  "The Canadian Wind Turbine Database contains the geographic location and key technology details for wind turbines installed in Canada. It includes information about turbines installed in {.{col_palette[[1]]} {names(col_palette)[[1]]}}, {.{col_palette[[2]]} {names(col_palette)[[2]]}}, {.{col_palette[[3]]} {names(col_palette)[[3]]}}, {.{col_palette[[4]]} {names(col_palette)[[4]]}}, {.{col_palette[[5]]} {names(col_palette)[[5]]}}, and {.{col_palette[[6]]} {names(col_palette)[[6]]}} regions."
)
```

Let's see what our subtitle looks like when the variables have been evaluated:

```{r}
#| label: turbines-text-show
st
```

This is the reason that we wanted the `"other"` category to be in lower case and in last position when constructing `area_levels` - to make the sentence read better.

We add these text elements to out plot in the normal way, by passing them into the `labs()` function: \index{ggplot2!labs}

```{r}
#| label: fig-turbines-text-plot
#| fig-cap: "Plot"
text_plot <- col_plot +
  labs(
    title = title,
    subtitle = st,
    caption = cap
  )
text_plot
```

You'll notice that the formatting hasn't been applied, and that the `**` have been rendered literally. We'll deal with this when we edit the arguments in `theme()` - we haven't actually used {marquee} yet to format the title text!

### Adjusting scales and themes

\index{ggplot2!scale\_x\_continuous} \index{ggplot2!scale\_y\_continuous}
\index{ggplot2!coord\_fixed}

```{r}
#| label: turbines-scale-plot
scale_plot <- text_plot +
  scale_x_discrete(
    expand = c(0, 0, 0, 0)
  ) +
  scale_y_continuous(
    labels = function(x) format(x * 10 * 20, big.mark = ","),
    expand = c(0, 0),
    breaks = c(0, 5, 10, 15, 20),
    limits = c(0, 20),
    minor_breaks = NULL
  ) +
  coord_fixed()
```

\index{ggplot2!theme\_minimal} \index{ggplot2!theme} \index{ggplot2!element\_rect}
\index{marquee!element\_marquee} \index{ggplot2!element\_line} \index{ggplot2!margin}

```{r}
knitr::opts_chunk$set(dev = "ragg_png")
```

```{r}
#| label: fig-turbines-theme-plot
#| fig-cap: "Plot"
scale_plot +
  theme_minimal(
    base_size = 8
  ) +
  theme(
    plot.title.position = "plot",
    plot.caption.position = "plot",
    plot.margin = margin(5, 10, 5, 10),
    plot.background = element_rect(fill = bg_col, colour = bg_col),
    panel.background = element_rect(fill = bg_col, colour = bg_col),
    panel.grid.major = element_line(
      linewidth = 0.4
    ),
    plot.title = marquee::element_marquee(
      colour = text_col,
      width = 1,
      size = 12,
      margin = margin(b = -10)
    ),
    plot.subtitle = marquee::element_marquee(
      colour = text_col,
      width = 1,
      size = 9
    ),
    plot.caption = marquee::element_marquee(
      hjust = 0,
      lineheight = 0.5,
      size = 8,
      margin = margin(t = 5)
    )
  )
```

fix order colors are plotted in

## Reflection

* turbines icon
