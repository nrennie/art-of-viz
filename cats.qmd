---
filters:
  - line-highlight
execute: 
  freeze: auto
fig-asp: 0.75
---

```{r}
#| echo: false
#| eval: true
#| file: R/options.R
```

```{r}
#| echo: false
#| eval: true
#| file: R/source_caption.R
```

# Cats: data-driven annotations with {ggtext} {#sec-cats}

In this chapter, we'll learn how to create custom captions with social media icons, and add data-driven annotations to our plots. 

## Data

Between 2013 and 2017, @kays2020 recruited volunteers in the United States of America, the United Kingdom, Australia, and New Zealand who volunteered to attach GPS sensors to their pet cats. The data [@cats_data] was collected because pet cats kill native species, such as birds, and this creates conservation issues. Studying how different cats move around when they're not at home, can help us to understand the impact of pet cats on our environment. In this chapter, we'll focus on the data from cats (and their owners!) based in the United Kingdom.

The data was used as a TidyTuesday dataset in January 2023 (after being suggested by [Tom Mock](https://github.com/jthomasmock)), and so can be loaded with the `tt_load()` function from {tidytuesdayR} [@tidytuesdayR]. There are two datasets included, which we'll read in as `cats` and `cats_reference`. \index{tidytuesdayR!tt\_load}

```{r}
#| label: cats-data-show
#| eval: false
#| echo: true
tuesdata <- tidytuesdayR::tt_load("2023-01-31")
cats <- tuesdata$cats_uk
cats_reference <- tuesdata$cats_uk_reference
```

```{r}
#| label: cats-data-hide
#| output: false
#| echo: false
#| eval: true
cats <- readr::read_csv("data/cats_uk.csv")
cats_reference <- readr::read_csv("data/cats_uk_reference.csv")
```

The `cats` data contains information from the sensors including the latitudes and longitudes recorded at different time stamps. There are multiple (many) observations for each cat, resulting in a total of `r nrow(cats)` rows across `r ncol(cats)` columns. Some of the observations have been marked as outliers, either by an automatic algorithm, manually, or both. The `cats_reference` data contains information provided by the cat owners on each individual cat such as their name, age, sex, how long they spend indoors, and what type of food they eat. The two datasets can be joined by the `tag_id` column that exists in both `cats` and `cats_reference`.

## Exploratory work

With the `cats` data, we could focus the spatial patterns and look at the range of where cats travel. For example, how far does the average cat travel in a day? Alternatively, we could focus on the `cats_reference` data and look at relationships between different behaviors and characteristics of cats. For example, do older cats spend more time indoors? Or do cats who live with other cats bring home more prey?

The third option, and perhaps the most useful, is to join the two datasets together. Joining the data on the individuals to their geographic data might allow us to answer questions such as: do male cats travel further per day? Do older cats stay closer to home? What are the strategies of a cat that brings home lots of *gifts*?

### Data exploration

Let's start by digging into the geographic `cats` data. We can make a very quick plot of the co-ordinate data using `plot()`. \index{graphics!plot}

```{r}
#| label: fig-cats-map
#| fig-cap: "Scatter plot showing the geographic coordinates obtained from the GPS data attached to pet cats. The lack of background map makes it hard to interpret without context, but some clusters can be seen."
#| echo: -1
par(mar = c(5.1, 4.1, 2.1, 2.1))
plot(
  cats$location_long, cats$location_lat,
  xlab = "Longitude", ylab = "Latitude"
)
```

Given that the data in @fig-cats-map is geographic coordinate data, we would be able to understand it a bit better with a background map to give more context to location and distance. However, even with this very minimal map, it's clear that there are lots of small clusters of points - perhaps each cluster is a specific cat?

::: {#tip-cats-lat-long .callout-tip}

## Remembering latitude and longitude

No matter how many times you plot them on a map, remembering which way round latitude and longitude go on the x- and y-axes might not seem to get any easier! One way to help you remember:

* Picture a world map. It's probably rectangular with the *long* edge going along the bottom.
* The *longitude* goes along the bottom i.e. the x-axis.

:::

The GPS sensors also report data on the ground speed of the cats, potentially allowing us to see patterns in their activity level throughout the day. Let's have a look at the `ground_speed` column by plotting an exploratory histogram with `hist()`: \index{graphics!hist}

```{r}
#| label: fig-cats-speed-hist
#| fig-cap: "Histogram of the ground speeds recorded from GPS sensors, showing a highly skewed distribution with some very high speeds!"
#| echo: -1
par(mar = c(5.1, 4.1, 3.1, 2.1))
hist(cats$ground_speed,
  xlab = "Ground speed (m/s)",
  main = "Histogram of ground speed"
)
```

At first glance you might not see anything of particular note about @fig-cats-speed-hist. However, the data description reports that the ground speed is measured in meters per second (m/s), but the histogram goes up to 250,000. For those of you who don't often work in m/s, that's about 560,000 miles per hour, or 900,000 kilometers per hour! Either these are exceptionally fast cats or there's an issue with the ground speed data. Perhaps the units were incorrectly recorded, or the sensors did not perform correctly. We don't know what the issue is, but this is certainly a column in the data that we shouldn't trust too much.

Let's focus on the `cats_reference` data instead, and look at how characteristics of the study cats varied. For example, we might look at how long the cats spend indoors, which is recorded as a categorical variable, `hrs_indoors`. We can calculate how many cats fall into each time indoors *category* using `table()` and then use `barplot()` to visualize it: \index{graphics!barplot} \index{base!table}

```{r}
#| label: fig-cats-bar-hrs
#| fig-cap: "Bar chart showing the number of cats that fall into each of the five categories for the average amount of time they spend indoors. Although the data may at first appear numeric, it is in fact categorical data."
#| echo: -1
par(mar = c(4.1, 4.1, 3.1, 2.1))
barplot(
  table(cats_reference$hrs_indoors)
)
```

We might expect that the number of hours a cat spends indoors varies with age, with older cats spending more time indoors due to health problems or energy levels. Let's use `plot()` to create a quick scatter plot of `age_years` against `hrs_indoors` to investigate: \index{graphics!plot}

```{r}
#| label: fig-cats-scatter
#| fig-cap: "Scatter plot of the relationship between the age of pet cats and the average amount of time they spend indoors. "
#| echo: -1
par(mar = c(5.1, 4.1, 2.1, 2.1))
plot(
  cats_reference$age_years, cats_reference$hrs_indoors,
  xlab = "Age", ylab = "Hours indoors"
)
```

There's a little bit of a pattern in @fig-cats-scatter, but not a particularly strong one. This is perhaps partly due to the categorical nature of the `hrs_indoors` column, since we lose information when we group data that is naturally continuous.

This categorization of data also results in many of the points being stacked on top of each other. There are `r nrow(cats_reference)` cats in the data, but there doesn't appear to be `r nrow(cats_reference)` points in @fig-cats-scatter. If we were to take the visualization further, we might consider changing it from a scatter plot to a bubble plot. With bubble plots, the size of the points relates to some other variable e.g. the number of cats in each `age_years`-`hrs_indoor` category combination.

### Exploratory sketches

Let's take the idea from @fig-cats-scatter but develop into a much more effective visualization, making particular use of text and annotations. We'll update the chart to make a bubble plot. But we'll also add annotations to highlight interesting aspects of the data e.g. the oldest cat, or the average amount of time spent indoors. @fig-cats-sketch gives a basic illustration of how we might develop it:

![Initial sketch of a bubble plot with annotations, to show the relationship between the age of pet cats and how much time they spend indoors.](images/sketch-cats.png){#fig-cats-sketch fig-align="center"}

## Preparing a plot

In order to create @fig-cats-sketch in {ggplot2}, we only need to work with two columns in the `cats_reference` data: the cat age, `age_years`, and the average number of hours per day spent indoors, `hrs_indoors`.

### Data wrangling

The `hrs_indoors` column contains five categories for time spend indoors: `2.5`, `7.5`, `12.5`, `17.5`, and `22.5`. Since these category names are numbers, they are encoded in R as numeric columns instead of categories, so we start by convert the `hrs_indoors` column to a `factor()`. To know how big the *bubbles* of our plot will be, we need to know how many cats there are for each combination of age and indoor time. We `group_by()` the two relevant columns and then use `count()` from {dplyr} to count the number of each category combination, before un-grouping with `ungroup()`. \index{dplyr!select} \index{dplyr!mutate} \index{base!factor} \index{dplyr!group\_by} \index{dplyr!count} \index{dplyr!ungroup} 

There's one cat (`r cats_reference$animal_id[is.na(cats_reference$age_years)]`) whose age is unknown, so we use `drop_na()` from {tidyr} to remove this value. See @sec-bees and @sec-r-pkgs for some other discussions on visualizing and dealing with missing values in your data. \index{tidyr!drop\_na} 

```{r}
#| label: cats-wrangling
plot_data <- cats_reference |>
  dplyr::select(age_years, hrs_indoors) |>
  dplyr::mutate(hrs_indoors = factor(hrs_indoors)) |>
  dplyr::group_by(age_years, hrs_indoors) |>
  dplyr::count() |>
  dplyr::ungroup() |>
  tidyr::drop_na()
```

### The first plot

We pass our data into the `ggplot()` function as always, and then set up the aesthetic mapping with `aes()`. As we did in @fig-cats-scatter, we put age on the x-axis and hours indoors on the y-axis. Here, we also map the number of cats in each category combination, `n`, to the `size` aesthetic to make the bubbles. Although we are making a bubble plot rather than a scatter plot, we still use `geom_point()` since both types of plots are made from points. Scatter plots are essentially a special case of bubble plots where all of the points represent one observation and so are all the same size. \index{ggplot2!ggplot} \index{ggplot2!aes} \index{ggplot2!geom\_point}

```{r}
#| label: fig-cats-base-plot
#| fig-cap: "Plot"
library(ggplot2)
base_plot <- ggplot(
  data = plot_data,
  mapping = aes(
    x = age_years,
    y = hrs_indoors,
    size = n
  )
) +
  geom_point()
base_plot
```

## Advanced styling

something here

### Colors

```{r}
#| label: cats-colors
text_col <- "#2F4F4F"
highlight_col <- "#914D76"
bg_col <- "white"
```

We can update our initial `base_plot` code to change the color of the points to `highlight_col` inside `geom_point()`. Remember that since this color isn't based on a column in the data, it doesn't need to go inside `aes()`. \index{ggplot2!ggplot} \index{ggplot2!aes} \index{ggplot2!geom\_point}

The `size` legend is generated automatically, and it picks evenly spaced intervals given the range of the data. Unfortunately this sometimes results in labels that don't quite make sense. Here, we have a label for 2.5 cats - not something that exists in the natural world! Let's choose more appropriate breaks for the `size` legend. Here, our `size` data ranges between `r min(plot_data$n)` and `r max(plot_data$n)`, so let's go for `3`, `6`, and `9`. We pass these desired break points in as a vector to `scale_size()`. Note that the sizes of the points in the plot are unchanged, only the legend is updated. \index{ggplot2!scale\_size}

```{r}
#| label: fig-cats-base-plot-2
#| fig-cap: "Plot"
#| source-line-numbers: "9,10"
base_plot <- ggplot(
  data = plot_data,
  mapping = aes(
    x = age_years,
    y = hrs_indoors,
    size = n
  )
) +
  geom_point(color = highlight_col) +
  scale_size(breaks = c(3, 6, 9))
base_plot
```

### Fonts

Fun and funky 

\index{sysfonts!font\_add\_google} \index{showtext!showtext\_auto} \index{showtext!showtext\_opts}

```{r}
#| label: cats-fonts
sysfonts::font_add_google(name = "Chewy")
sysfonts::font_add_google(name = "Ubuntu")
showtext::showtext_auto()
showtext::showtext_opts(dpi = 300)
title_font <- "Chewy"
body_font <- "Ubuntu"
```

### Adding annotations

Charts are considered *visual* elements. And the quote *a picture is worth a thousand words* is often floated around as motivation for why you should visualize your data instead of describing it. But just because you're making a *picture* doesn't mean you can't also use words. It's not necessarily a weakness of a chart, if adding some textual indicators improves its clarity.

In @sec-programming, when we constructed the subtitle, we used `glue()` to create data-driven text. This meant that, if the underlying data was updated, the subtitle would also be updated correctly. It's a more efficient approach that's less prone to accidental errors than *hard coding* all of the text. We can take a similar approach when adding annotations to plots.

Let's say we want to add an annotation to the plot that highlights the oldest cat in the data. We'll start by obtaining the data that relates to the oldest cat. We can use `slice_max()` from {dplyr} to obtain the row of the data where the `age_years` is highest: \index{ggplot2!slice\_max}

```{r}
#| label: cats-oldest 
annot_oldest <- cats_reference |>
  dplyr::slice_max(age_years)
```

When it comes to adding the annotation to the plot, there are several options: `annotate()` which ; `geom_text()`; or `geom_label()` which works similarly to `geom_text()` ... . Here, annotate ... 

However, we're going to use {ggtext} [@ggtext] instead of just {ggplot2}. The {ggtext} package will allow us to ... . We've already seen examples of using {ggtext} for automatically wrapping long strings, but we're going to showcase some of its other features here - such as coloring and highlighting specific elements of text. We've already seen examples of coloring sections of text in @sec-turbines using the {marquee} package, but we'll look at {ggtext} as a comparison.

explain code below



Although we've used .. `geom_textbox()`, you can ...something similar in subtitle, element_textbox simple 

\index{ggplot2!aes} \index{ggtext!geom\_textbox} \index{glue!glue}

```{r}
#| label: fig-cats-annot-1
#| fig-cap: "Plot"
annotated_plot <- base_plot +
  ggtext::geom_textbox(
    data = annot_oldest,
    mapping = aes(
      x = age_years - 2.5,
      y = factor(hrs_indoors),
      label = glue::glue(
        "The oldest cat is <span style='color:{highlight_col}'>{animal_id}</span> who is {age_years} years old."
      )
    ),
    halign = 0.5, hjust = 0.5,
    size = 2.5,
    lineheight = 0.5,
    family = body_font,
    box.color = text_col,
    color = text_col,
    alpha = 0.5,
    maxheight = unit(4, "lines"),
    minwidth = unit(2, "lines"),
    maxwidth = unit(4, "lines")
  )
annotated_plot
```

::: {#tip-cats-repel .callout-tip}

## Non-overlapping labels

Here, we're only positioning one annotation and so it's reasonably easy to ... adjust the position manually. If you have many textual annotations , and they ... ., the {ggrepel} package [@ggrepel] may help. It ...

:::

\index{ggplot2!annotate} \index{grid!arrow} \index{grid!unit}

thing about factors

If you want to add a straight line arrow, you can set `geom = "segment"`, but curved arrows often look less severe.

```{r}
#| label: fig-cats-arrow
#| fig-cap: "Plot"
arrow_plot <- annotated_plot +
  annotate(
    geom = "curve",
    x = 15.1,
    xend = 16,
    y = 4.6,
    yend = 4.9,
    linewidth = 0.3,
    color = text_col,
    curvature = 0.5,
    arrow = arrow(length = unit(1.5, "mm"), type = "closed")
  )
arrow_plot
```

::: {#tip-cats-highlight .callout-tip}

## Highlighting observations in data

In @sec-museums, we used {gghighlight} [@gghighlight] to ... 

:::

### Adding text

```{r}
#| label: cats-text-1
# title text
title <- "Do older cats spend more time indoors?"

# subtitle text
perc_indoor <- round(100 * sum(cats_reference$hrs_indoors == "22.5") / nrow(cats_reference))
st <- glue::glue("Around {perc_indoor}% of cats in the study spend on average 22.5 hours per day indoors! There is a slight trend for cats to spend more time indoors as they age.")
```

### Custom caption functions

When we constructed the `source_caption()` function in @sec-turbines, we simply passed in a character string to indicate the name of the creator of the chart (e.g. `"N. Rennie"`). What might be more useful is a way to contact or better identify the author of the chart. This could allow readers to dig into the data or code if they choose to, and allow chart creators to more easily link to other examples of their work. It's very common in websites, for example, to link to social media profiles. We can actually do something very similar for a static chart [@social_icons]. 

Instead of simply passing in a character string with a name, we'll create a caption that contains social media icons and the associated handles. Since this is something we are likely to add to multiple different plots (and perhaps with different social media details), we'll create a function that produces this caption based on some user inputs. 

But first, before we jump into writing functions, we need to get some social media icons! As we did in @sec-turbines, we'll again use [Font Awesome](https://fontawesome.com/) icons [@fontawesome], but this time we'll use the *Brand* pack of icons instead of the *Solid* icons. The process of loading the icons here is essentially the same as loading the Font Awesome icons in @sec-turbines. After you've downloaded zip file of freely available icons from [fontawesome.com/download](https://fontawesome.com/download), selecting the **Free for Desktop** option, you should see a file called `Font-Awesome-6-Brands-Regular-400.otf`. Again, save this `.otf` file somewhere you can find it again - such as in a project folder called `fonts`. 

As before, we'll use `font_add()` from {sysfonts} [@sysfonts] to load the font into R. The `family` argument is how we'll refer to the font  in R, and the `regular` argument is the file path to the `.otf` file. We then use `showtext_auto()` and `showtext_opts()` to use {showtext} to render the text and set the desired resolution.  \index{sysfonts!font\_add} \index{showtext!showtext\_auto} \index{showtext!showtext\_opts}

```{r}
#| echo: true
#| eval: true
#| file: R/load_font_awesome.R
```

Let's go back to adding social media icons and create a function, `social_caption()` that will write the caption for us. We start by thinking about what options should be user specified:

* A choice of which social media icons and handles are included. We want users to be able to update the handle that goes with a particular social media icon e.g. for switching between work and personal accounts.
We should also give a user the option to *switch off* a specific social media icon if they want to.
* The colors of the icons and the fonts. We might choose to force these to be the same, or allow them to be different.
* The font of the non-icon text i.e. the social media handles. We want a user to be able to pass in their choice of font to match with the text in the rest of their chart.

To construct this example `social_caption()` function, we'll include icons for LinkedIn, GitHub, and BlueSky. You might choose to include others. We'll have one argument in the function for each of these social media sites, with the default value specified as the handle that will be used most often. We also add two arguments to control the icon and font colors: `icon_color` and `font_color`. Both are set to `"black"` by default, which is consistent with other {ggplot2} text.

need bg_col?
default font

Within the function, we start by putting together a list of ... for the relevant social media icons. As we did when looking for the ... icon in @sec-turbines..., we can search for e.g. the GitHub icon on ..., and look in the ... 

\index{social\_caption} \index{base!list} \index{glue!glue}

you could also use purrr, dplyr 

[@ggtext]

```{r}
#| echo: true
#| eval: true
#| file: R/social_caption.R
```

We can then use the `social_caption()` function, passing in the color and font variables we've previously defined to their relevant arguments:

```{r}
#| label: cats-social
social <- social_caption(
  bg_color = bg_col,
  icon_color = highlight_col,
  font_color = text_col,
  font_family = body_font
)
social
```

You can see that the output of the `social_caption()` is a pretty incomprehensible string that would've been quite tricky to type out manually - aren't we glad we built a function to do it for us! We can then use our `source_caption()` function from @sec-turbines, and pass the output from the `social_caption()` function into the `graphic` argument. We also place them on separate lines by using `<br>`. \index{source\_caption}

```{r}
#| label: cats-source-cap
cap <- source_caption(
  source = "McDonald JL, Cole H. 2020. doi.org/10.5441/001/1.pf315732.",
  sep = "<br>",
  graphic = social
)
```

The text can then be added to @fig-cats-arrow using the `labs()` function as normal, by passing in the variables to the `title`, `subtitle`, and `caption` arguments. We also add more informative text for the title on the x and y axes, making sure to also specify the units. \index{ggplot2!labs}

By default, the legend title is simply the name of the column mapped to the aesthetic in the legend. Here, the column mapped to `size` is `n` and so that's the name of the legend, which isn't very informative. There are several different ways to edit the name of the legend. We could have specified the `name` argument when we used `scale_size()` earlier. An alternative, is to use the `labs()` function. The title for any aesthetic can be specified in `labs()`, not just `x` and `y`. We simply pass the desired legend title into `size`.

```{r}
#| label: fig-cats-text-plot
#| fig-cap: "Plot"
text_plot <- arrow_plot +
  labs(
    title = title,
    subtitle = st,
    caption = cap,
    x = "Age of cat (years)",
    y = "Average time spent indoors (hours per day)",
    size = "Number of cats"
  )
text_plot
```

### Adjusting themes


\index{ggplot2!theme\_minimal} \index{ggplot2!theme} \index{ggplot2!element\_text}
\index{ggtext!element\_textbox\_simple} \index{ggplot2!element\_blank} \index{ggplot2!element\_rect}

overlaying legend add outline box to distinguish between points on chart, and points in legend

```{r}
#| label: fig-cats-styled-plot
#| fig-cap: "Plot"
text_plot +
  theme_minimal(base_family = body_font, base_size = 6.5) +
  theme(
    # legend styling
    legend.position = "inside",
    legend.position.inside = c(0.9, 0.25),
    legend.background = element_rect(
      fill = alpha(bg_col, 0.6),
      color = text_col
    ),
    # text
    text = element_text(color = text_col),
    plot.title = element_text(
      family = title_font,
      face = "bold",
      size = rel(1.5)
    ),
    plot.subtitle = ggtext::element_textbox_simple(),
    plot.caption = ggtext::element_textbox_simple(),
    plot.title.position = "plot",
    plot.caption.position = "plot",
    # background and grid
    plot.margin = margin(5, 5, 5, 5),
    panel.grid.minor = element_blank(),
    plot.background = element_rect(
      fill = bg_col,
      color = bg_col
    ),
    panel.background = element_rect(
      fill = bg_col,
      color = bg_col
    )
  )
```

We can then finally save the chart in PNG format using `ggsave()`: \index{ggplot2!ggsave}

```{r}
#| label: cats-save
#| eval: false
#| echo: true
ggsave(
  filename = "cats.png",
  width = 5,
  height = 0.75*5
)
```

## Reflection

In this chart, we've considered only two variables, and there are many 

The legend box and the annotation box currently look quite different. The legend box has square corners, compared to rounded corners, and the outline color is darker. For consistency, it would look better if both boxes appear with the same styling. 


::: {.content-visible when-format="html"}

Each plot created during the process of developing the original version of this visualization was captured using {camcorder}, and is shown in the gif below. If you'd like to learn more about how {camcorder} can be used in the data visualization process, see @sec-camcorder.

![](images/cats.gif){fig-align="center"}

:::
